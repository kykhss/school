<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Timetable Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@tailwindcss/browser@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <style>
        /* Custom styles for the message box */
        #message-box {
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f0fdf4;
            color: #15803d;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #16a34a;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 100; /* Higher than modal */
            white-space: nowrap; /* Keep message on one line */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #message-box.show {
            display: block;
        }
        #message-box.error {
            background-color: #fee2e2;
            color: #dc2626;
            border-color: #dc2626;
        }
        #message-box.info {
            background-color: #e0f2fe;
            color: #0369a1;
            border-color: #38bdf8;
        }

        /* Loading Overlay */
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            flex-direction: column;
            gap: 1rem;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Table specific styles */
        .table-container {
            overflow: auto; /* Changed to auto for both x and y */
            margin-top: 1rem;
        }
        .timetable-table {
            border-collapse: collapse;
            width: 100%; /* Make table take full width of its container */
            table-layout: fixed; /* Distribute columns evenly, or based on content if widths are not set */
            margin-bottom: 2rem;
        }
        .timetable-table th, .timetable-table td {
            border: 1px solid #e5e7eb;
            padding: 0.2rem;
            text-align: center;
            vertical-align: middle;
            font-size: 0.7rem; /* Slightly smaller font for compactness */
            word-wrap: break-word; /* Allow long words to break */
        }
        /* Specific width for the first few columns in full view to ensure they don't shrink too much */
        .timetable-table.all-view th:nth-child(1),
        .timetable-table.all-view td:nth-child(1) { width: 5ch; } /* Teacher ID */
        .timetable-table.all-view th:nth-child(2),
        .timetable-table.all-view td:nth-child(2) { width: 10ch; } /* Teacher Name */
        .timetable-table.all-view th:nth-child(3),
        .timetable-table.all-view td:nth-child(3) { width: 10ch; } /* Class In Charge */
        /* Remaining columns will share the rest of the width in fixed layout */
        .timetable-table.all-view th:nth-child(n+4),
        .timetable-table.all-view td:nth-child(n+4) {
            /* width: calc((100% - 90px) / 42); Distribute remaining width among 42 period columns */
           width:40px;
            min-width: 10px; /* Ensure a minimum width for period cells for readability */
        }

        .timetable-table th {
            background-color: #f9fafb;
            font-weight: 600; /* Slightly bolder */
            position: sticky;
            top: 0; /* Sticky to top */
            z-index: 10; /* Higher z-index for top headers */
        }
        /* New: Sticky first column for day names in class/teacher view */
        .timetable-table th:first-child,
        .timetable-table td:first-child {
            position: sticky;
            left: 0;
            background-color: #f9fafb; /* or white for td */
            z-index: 12; /* Higher than other sticky headers and top headers */
        }
        .timetable-table tbody td:first-child {
            background-color: #ffffff; /* Ensure background is white when scrolled */
            font-weight: 600;
            text-align: left;
            padding-left: 1rem;
        }

        /* Styles for the "all" timetable view specific sticky columns */
        .timetable-table.all-view th:nth-child(-n+3) { /* Sticky for first three columns in 'all' view */
            position: sticky;
            left: 0;
            z-index: 11; /* Higher z-index to stay above other sticky headers (but below corner) */
            background-color: #f9fafb;
        }
        .timetable-table.all-view tbody td:nth-child(-n+3) { /* Sticky for first three columns in tbody in 'all' view */
            position: sticky;
            left: 0;
            background-color: #ffffff; /* Ensure background is white when scrolled */
            z-index: 9; /* Lower than headers */
        }
        /* Corner cell in all-view (intersection of top and left sticky headers) */
        .timetable-table.all-view th:first-child {
            z-index: 13; /* Highest z-index for the corner */
        }

        .timetable-table.individual-view{
            font-size:1rem;
        }
        /* Styles for individual teacher/class view specific sticky columns */
        .timetable-table.individual-view th:nth-child(1) { /* Sticky for the first column (Day) */
            position: sticky;
            left: 0;
            z-index: 12; /* Higher than other sticky headers */
            background-color: #f9fafb;
        }
        .timetable-table.individual-view tbody td:nth-child(1) { /* Sticky for the first column (Day) in tbody */
            position: sticky;
            left: 0;
            background-color: #ffffff;
            z-index: 9; /* Lower than headers */
        }
        /* Individual view period columns */
        .timetable-table.individual-view th:nth-child(n+2),
        .timetable-table.individual-view td:nth-child(n+2) {
            width: calc((100% - 100px) / 7); /* Distribute remaining width among 7 period columns */
            min-width: 80px; /* Ensure a minimum width for period cells */
        }


        /* New styles for interactive features */
        .slot-card {
            background-color: #e0f2fe;
            color: #0369a1;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            border: 1px solid #b7d9f3;
            cursor: pointer; /* Indicate it's clickable */
            transition: background-color 0.2s, border-color 0.2s;
        }
        .slot-card:hover {
            background-color: #90cdf4; /* Lighter blue on hover */
        }
        .slot-card.selected {
            background-color: #0369a1; /* Darker blue when selected */
            color: white;
            border-color: #0369a1;
        }

        /* Highlighting for cells */
        .highlight-possible {
            background-color: #d1fae5 !important; /* Light green */
            cursor: pointer; /* Indicate it's clickable to here */
            border: 2px solid #34d399 !important; /* Stronger border */
            transition: background-color 0.1s, border-color 0.1s;
        }
        .highlight-possible:hover {
            background-color: #a7f3d0 !important; /* Lighter green on hover */
        }
        .highlight-swappable {
            background-color: #fef3c7 !important; /* Light yellow */
            cursor: pointer; /* Indicate it's clickable to here */
            border: 2px solid #fbbf24 !important; /* Orange border */
            transition: background-color 0.1s, border-color 0.1s;
        }
        .highlight-swappable:hover {
            background-color: #fde68a !important; /* Lighter yellow on hover */
        }
        .highlight-conflict {
            background-color: #fee2e2 !important;
            cursor: not-allowed;
            border: 2px solid #ef4444 !important;
        }
        /* Highlight for the relevant teacher's row */
        .highlight-relevant-row {
            background-color: #6b92e0; /* Light gray for the relevant row */
            border-left: 3px solid #6366f1; /* Left border to emphasize */
            font-weight: bolder;
            z-index: 500px;
        }


        #available-slots-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
            max-height: 200px; /* Set max height */
            overflow-y: auto; /* Enable vertical scrolling */
            align-content: flex-start; /* Align items to the start of the container */
        }
        #available-slots-container h3 {
            width: 100%; /* Ensure heading takes full width */
            margin-bottom: 0.5rem;
        }


        /* The Modal (background) */
        .modal {
            display: none;
            position: fixed;
            z-index: 100; /* High z-index to be on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6); /* Darker overlay */
        }

        /* Modal Content/Box */
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; /* Adjusted margin */
            padding: 30px; /* More padding */
            border: 1px solid #888;
            width: 80%; /* Wider modal */
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Add shadow */
        }

        /* The Close Button */
        .close {
            color: #aaa;
            float: right;
            font-size: 32px; /* Larger close button */
            font-weight: bold;
            margin-left: auto;
        }

        .close:hover,
        .close:focus {
            color: #333; /* Darker on hover */
            text-decoration: none;
            cursor: pointer;
        }

        .modal-content h2 {
            font-size: 1.75rem; /* Larger heading */
            font-weight: 700;
            color: #333;
            margin-bottom: 1rem;
        }

        .modal-content p {
            margin-bottom: 0.75rem;
            color: #555;
        }

        .modal-content ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            color: #555;
        }

        .modal-content li {
            margin-bottom: 0.5rem;
        }

        /* Professional Look for dropdowns and buttons */
        .controls-group { /* General class for groups of controls */
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 2rem;
            align-items: flex-end; /* Align items to the bottom */
        }
        .controls-group > div {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        .controls-group label {
            margin-bottom: 0.25rem;
            font-weight: 600; /* Bolder label */
            color: #374151; /* Darker gray */
        }
        select {
            padding: 0.75rem 1rem; /* More padding */
            border-radius: 0.5rem; /* More rounded */
            border: 1px solid #d1d5db;
            font-size: 1rem; /* Larger font */
            background-color: #f9fafb; /* Light background */
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em 1.5em;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }
        select:focus {
            outline: none;
            border-color: #2563eb; /* Blue 600 on focus */
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3); /* Blue 600 with opacity */
        }

        .action-button { /* General class for various action buttons */
            background-color: #10b981; /* Emerald 500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: none;
            font-size: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .action-button:hover {
            background-color: #059669; /* Emerald 600 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .action-button:disabled {
            background-color: #d1d5db; /* Gray 300 */
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        /* Specific style for buttons */
        .generate-button {
            background-color: #2563eb; /* Blue 600 */
        }
        .generate-button:hover {
            background-color: #1d4ed8; /* Blue 700 */
        }

        .view-button { /* For view class/teacher buttons */
            background-color: #10b981; /* Emerald 500 */
        }
        .view-button:hover {
            background-color: #059669; /* Emerald 600 */
        }
        /* Specific style for the "All Timetable" button */
        #view-all-timetable-button {
            background-color: #6366f1; /* Indigo 500 */
        }
        #view-all-timetable-button:hover {
            background-color: #4f46e5; /* Indigo 600 */
        }

        /* Print button style */
        .print-button {
            background-color: #f97316; /* Orange 500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: none;
            font-size: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 0.5rem; /* Add some space from view buttons */
        }

        .print-button:hover {
            background-color: #ea580c; /* Orange 600 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .print-button:disabled {
            background-color: #d1d5db; /* Gray 300 */
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        /* Timetable table headers for individual teacher/class view */
        .timetable-table.individual-view th:not(:first-child) { /* All except the first (Day) column */
            text-align: center;
        }
        .timetable-table.individual-view th:first-child {
            text-align: left;
            padding-left: 1rem;
        }
        .timetable-table.individual-view td {
            height: 60px; /* Fixed height for cells for consistent look */
        }

        /* Tab styles */
        .tab-buttons {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f9fafb;
            cursor: pointer;
            font-weight: 600;
            color: #6b7280;
            transition: all 0.2s ease-in-out;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        .tab-button:hover {
            background-color: #e5e7eb;
            color: #374151;
        }
        .tab-button.active {
            background-color: #ffffff;
            border-color: #e5e7eb;
            border-bottom-color: transparent;
            color: #1f2937;
        }
        .tab-content {
            display: none;
            padding-top: 1rem;
        }
        .tab-content.active {
            display: block;
        }

        /* Report table styles */
        .report-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .report-table th, .report-table td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
            font-size: 0.9rem;
        }
        .report-table th {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        .report-table tfoot tr {
            font-weight: 700;
            background-color: #e2e8f0; /* Light blue-gray for totals */
        }
        .unassigned-subject {
            color: #dc2626; /* Red color for unassigned subjects */
            font-weight: 500;
        }

        /* Styles for locked cells */
        .locked-cell {
            background-color: #fefcbf !important; /* Light yellow background */
            border: 2px solid #facc15 !important; /* Yellow border */
            font-weight: 600;
        }

        /* Custom Context Menu */
        #custom-context-menu {
            position: fixed;
            z-index: 200;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0.25rem 0;
            min-width: 150px;
        }
        #custom-context-menu button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 0.5rem 1rem;
            color: #374151;
            font-size: 0.9rem;
            background: none;
            border: none;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        #custom-context-menu button:hover {
            background-color: #f3f4f6;
        }
        #custom-context-menu button:disabled {
            color: #9ca3af;
            cursor: not-allowed;
            background-color: transparent;
        }

        /* Styles for the moving element */
        .moving-slot {
            position: fixed;
            pointer-events: none; /* Allow events to pass through to elements below */
            z-index: 9999; /* Ensure it's on top */
            background-color: rgba(37, 99, 235, 0.8); /* Blue 600 with transparency */
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -50%); /* Center the element on the cursor */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px; /* Limit width */
        }


        /* Print-specific styles */
        @media print {
            body {
                background-color: #fff;
                margin: 0;
            }
            .container, .tab-buttons, .controls-group, #message-box, #available-slots-container, #regenerate-button, #clear-saved-data-button, #loading-overlay, #custom-context-menu, .filter-controls, .individual-timetable-controls, #clear-all-assignments-button, #fill-empty-slots-button, #undo-button, #redo-button {
                display: none !important;
            }
            .timetable-table {
                width: 100%;
                border-collapse: collapse;
                page-break-after: always; /* Ensure each table prints on a new page */
            }
            .timetable-table th, .timetable-table td {
                border: 1px solid #000;
                padding: 5px;
                font-size: 10px;
                text-align: center;
                vertical-align: top;
            }
            .timetable-table th {
                background-color: #eee;
            }
            /* Ensure sticky columns don't interfere with print layout */
            .timetable-table th:first-child,
            .timetable-table td:first-child,
            .timetable-table.all-view th:nth-child(-n+3),
            .timetable-table.all-view tbody td:nth-child(-n+3),
            .timetable-table.individual-view th:nth-child(1),
            .timetable-table.individual-view tbody td:nth-child(1) {
                position: static;
                left: auto;
                z-index: auto;
                background-color: transparent;
            }
            
            /* Add styles for teacher summary in print */
            .teacher-print-summary {
                margin-bottom: 15px;
                font-size: 0.85rem;
                text-align: left;
                border: 1px solid #ddd;
                padding: 10px;
                border-radius: 5px;
                background-color: #f9f9f9;
            }
            .teacher-print-summary h3 {
                font-size: 1rem;
                margin-top: 0;
                margin-bottom: 5px;
                color: #333;
            }
            .teacher-print-summary p {
                margin: 0;
                line-height: 1.4;
            }
        }
        .side-panel {
  position: fixed;
  top: 1px;
  left: 20px;
  width: 80%;
  background: #f9f9f9;
  border: 2px solid #ccc;
  border-radius: 8px;
  padding: 1px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  z-index: 1000;
  max-height: 45vh;
  overflow: auto;
  
  animation: fadeIn 0.5s ease-in-out;
}

.mini-timetable {
  font-size: 6px;
  width: 100%;
  text-wrap:auto;
}
.mini-timetable table{
    border: 1px solid black;
}
.mini-timetable td{
    border: 1px solid black;
    max-width: fit-content;
    padding: 2px;
    height: fit-content;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.mini-popup {
    background: #fff;
    border: 1px solid #ccc;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    border-radius: 8px;
    padding: 0;
    transition: opacity 0.3s ease;
}

.mini-popup-header {
    background: #f5f5f5;
    cursor: move;
    padding: 8px 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    border-bottom: 1px solid #ddd;
}

.popup-actions button {
    background: none;
    border: none;
    font-size: 16px;
    cursor: pointer;
    margin-left: 6px;
}

.mini-popup-body {
    padding: 10px;
    overflow-x: auto;
}

.resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    bottom: 0;
    right: 0;
    cursor: se-resize;
    background: #ccc;
    border-bottom-right-radius: 6px;
}
.mini-popup {
    opacity: 0;
    animation: fadeIn 0.3s forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}


    </style>
</head>
<body class="bg-gray-100 font-inter">
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Loading...</p>
    </div>

    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-semibold text-gray-800 text-center mb-6">Advanced Timetable Generator</h1>
        <p class="text-center text-gray-600 mb-4">Your User ID: <span id="user-id-display" class="font-bold text-blue-700">Loading...</span><span><button id="loadFromFirebaseBtn" class="btn btn-primary">
  🔄 Load from Firebase
</button></span>
</p>
        
        <div id="message-box" class="hidden"></div>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="timetable-management-tab">Timetable Management</button>
            <button class="tab-button" data-tab="reports-tab">Reports</button>
        </div>

        <div id="timetable-management-tab" class="tab-content active">
            <div class="bg-white shadow-md rounded-lg p-6 mb-6">
                <div class="flex flex-col sm:flex-row items-center gap-4 mb-4">
                    <input type="file" id="file-input" accept=".csv, .xlsx" class="hidden">
                    <div class="flex items-center gap-4" style="display: none;">
                        <input type="radio" id="demo-data-radio" name="data-source" value="demo" readonly disabled class="mr-2">
                        <label for="demo-data-radio" class="text-gray-700">Use Demo Data</label>
                        <input type="radio" id="original-data-radio" name="data-source" value="original" class="mr-2" checked>
                        <label for="original-data-radio" class="text-gray-700" >Use Imported Data</label>
                    </div>
                    <button id="import-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Import CSV/Excel
                    </button>
                    <button id="create-slots-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 transition ease-in-out duration-150" disabled>
                        Create Slots & Generate
                    </button>
                    <button id="export-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition ease-in-out duration-150" disabled>
                        Export to Excel
                    </button>
                    <button id="export-to-firestore-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition ease-in-out duration-150" disabled>
                        Export Timetable to Cloud
                    </button>
                    <button id="download-template" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Download Template
                    </button>
                    
                </div>
               <label for="weeklyDays">Working Days (1–6):</label>
                <input type="number" id="weeklyDays" min="1" max="6" value="6" />

                <label for="periodsPerDay">Periods Per Day:</label>
                <input type="number" id="periodsPerDay" min="1" max="10" value="7" />

                <label for="relaxiationPerDay">Relaxiation:</label>
                <input type="number" id="relaxiationPerDay" min="2" max="10" value="4" />


                <p class="text-gray-600 mt-2 text-sm">First, import data or select "Use Demo Data", then click "Create Slots & Generate".</p>

                <div id="header-modal" class="modal">
                    <div class="modal-content">
                        <span class="close">&times;</span>
                        <h2>Expected File Header Structure</h2>
                        <p>Please ensure your CSV/Excel file has the following **exact** headers in the first row:</p>
                        <ol>
                            <li>**Teacher ID**</li>
                            <li>**Teacher Name**</li>
                            <li>**Class In Charge**</li>
                            <li>**Subject Class-Subject Name-Hours** (e.g., "10A-Mathematics-5", "9B-English-4") - You can have multiple such columns (e.g., Subject1, Subject2, etc.)</li>
                            <li>**Unavailable Periods** (Comma-separated, e.g., "Mo1, Tu3, Fr2")</li>
                        </ol>
                        <p>Each row represents a teacher and the subjects they teach to a specific class, along with their weekly hours for that subject and their unavailable periods.</p>
                        <button id="select-file-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition ease-in-out duration-150">Select File</button>
                    </div>
                </div>
            </div>

            <div id="management-actions-section" class="bg-white shadow-md rounded-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Manual Assignments & Management</h2>
                
                <div class="controls-group">
                    <div class="flex-grow">
                        <label for="full-timetable-label" class="block text-sm font-medium text-gray-700">Full School Timetable:</label>
                        <button id="view-all-timetable-button" class="action-button generate-button" disabled>View/Edit Full Timetable</button>
                    </div>
                </div>

                <div class="individual-timetable-controls flex flex-wrap gap-4 mb-4">
                    <div class="flex-grow">
                        <label for="teacher-dropdown-editable" class="block text-sm font-medium text-gray-700">View/Edit Teacher Timetable:</label>
                        <select id="teacher-dropdown-editable" disabled class="mt-1 block w-full">
                            <option value="">Select Teacher</option>
                        </select>
                    </div>
                    <div class="flex flex-col justify-end">
                        <button id="view-teacher-timetable-editable-button" disabled class="action-button view-button">View/Edit Teacher Timetable</button>
                    </div>
                    <div class="flex-grow">
                        <label for="class-dropdown-editable" class="block text-sm font-medium text-gray-700">View/Edit Class Timetable:</label>
                        <select id="class-dropdown-editable" disabled class="mt-1 block w-full">
                            <option value="">Select Class</option>
                        </select>
                    </div>
                    <div class="flex flex-col justify-end">
                        <button id="view-class-timetable-editable-button" disabled class="action-button view-button">View/Edit Class Timetable</button>
                    </div>
                </div>


                <div class="filter-controls flex flex-wrap gap-4 mb-4">
                    <div class="flex-grow">
                        <label for="filter-unassigned-class-dropdown" class="block text-sm font-medium text-gray-700">Filter Unassigned by Class:</label>
                        <select id="filter-unassigned-class-dropdown" class="mt-1 block w-full">
                            <option value="">All Classes</option>
                        </select>
                    </div>
                    <div class="flex-grow">
                        <label for="filter-unassigned-teacher-dropdown" class="block text-sm font-medium text-gray-700">Filter Unassigned by Teacher:</label>
                        <select id="filter-unassigned-teacher-dropdown" class="mt-1 block w-full">
                            <option value="">All Teachers</option>
                        </select>
                    </div>
                    <div class="flex flex-col justify-end">
                        <button id="clear-unassigned-filters-button" class="action-button bg-gray-500 hover:bg-gray-600">Clear Filters</button>
                    </div>
                </div>

                <div id="available-slots-container">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Unassigned Slots: <span class="text-sm text-gray-500">(Click a slot to assign it manually)</span></h3>
                    <p class="text-gray-500" id="no-unassigned-message">No unassigned slots!</p>
                </div>
                
                <div class="flex flex-wrap gap-4 mt-4">
                    <button id="regenerate-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Regenerate Timetable
                    </button>
                    <button id="fill-empty-slots-button" class=" bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Fill Empty Slots (Unassigned)
                    </button>
                    <button id="clear-all-assignments-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Clear All Assignments
                    </button>
                    <button id="clear-saved-data-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition ease-in-out duration-150">
                        Clear All Saved Data
                    </button>
                    <button id="undo-button" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-opacity-50 transition ease-in-out duration-150" disabled>
                        Undo Last Action
                    </button>
                    <button id="redo-button" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-opacity-50 transition ease-in-out duration-150" disabled>
                        Redo Last Action
                    </button>
                </div>

                <div id="timetable-container" class="hidden bg-white shadow-md rounded-lg p-4 mt-6">
                    <h2 id="timetable-title" class="text-2xl font-semibold text-gray-800 text-center mb-4">Generated Timetable</h2>
                    <div class="table-container">
                      <table id="timetable-table" class="timetable-table">
                          <thead>
                              </thead>
                          <tbody>
                          </tbody>
                      </table>
                    </div>
                </div>

                <div id="individual-timetable-display" class="hidden bg-white shadow-md rounded-lg p-4 mt-6">
                    <h2 id="individual-timetable-title" class="text-2xl font-semibold text-gray-800 text-center mb-4">Selected Timetable</h2>
                    <div class="table-container">
                      <table id="individual-timetable-table" class="timetable-table">
                          <thead>
                              </thead>
                          <tbody>
                          </tbody>
                      </table>
                    </div>
                </div>

                <!-- This container will display the side view (teacher/class timetable when viewing class/teacher respectively) -->
<div id="secondary-timetable-display" class="side-panel hidden">
  <h3 id="secondary-timetable-title" class="table-container"></h3>
  <div class="timetable-table">
  <table id="secondary-timetable-table" class=" mini-timetable">
    <thead></thead>
    <tbody></tbody>
  </table>
  </div>
</div>





            </div>
        </div>
        
        <div id="reports-tab" class="tab-content">
            <div class="bg-white shadow-md rounded-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Timetable Reports</h2>

                <div class="mb-6">
                    <h3 class="text-xl font-semibold text-gray-700 mb-2">Teacher Reports</h3>
                    <div class="table-container">
                        <table id="teacher-report-table" class="report-table">
                            <thead>
                                <tr>
                                    <th>Teacher ID</th>
                                    <th>Teacher Name</th>
                                    <th>classCharge</th> 
                                    <th>Total Required Periods</th>
                                    <th>Total Unassigned Periods</th>
                                </tr>
                            </thead>
                            <tbody>
                                </tbody>
                            <tfoot>
                                </tfoot>
                        </table>
                    </div>
                    <button id="print-teacher-report-button">🖨️ Print Teacher Report</button>
                
                    <button id="print-all-teacher-timetables-button" class="print-button mt-4">Print All Teacher Timetables with Summary</button>
                
                </div>

                <div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-2">Class Reports</h3>
                    <div class="table-container">
                        <table id="class-report-table" class="report-table">
                            <thead>
                                <tr>
                                    <th>Class</th>
                                    <th>Total Required Periods</th> <th>Total Assigned Periods</th>
                                    <th>Total Unassigned Periods</th>
                                    <th>Subjects (Assigned/Unassigned)</th>
                                </tr>
                            </thead>
                            <tbody>
                                </tbody>
                            <tfoot>
                                </tfoot>
                        </table>
                    </div>
                    <button id="printclassreport-button" onclick="printClassReport()">🖨️ Print Class Report</button>
                    <button id="print-all-class-timetables-button" class="print-button mt-4">Print All Class Timetables</button>
                </div>
            </div>
        </div>
    </div>

    <div id="custom-context-menu" class="fixed z-200 bg-white border border-gray-300 rounded shadow-lg py-1 hidden">
        <button id="lock-unlock-option" class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-100">
            Lock/Unlock Slot
        </button>
        <button id="unassign-slot-option" class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-100">
            Unassign Slot
        </button>
    </div>

    <script type="module">
        function base64Encode(str) {
                return btoa(unescape(encodeURIComponent(str)));
            }

        function setBase64ParamsInUrl(userId) {
                const encoded = base64Encode(userId);
                const newUrl = `${window.location.pathname}?wxev=${encodeURIComponent(encoded)}`;
                window.history.replaceState({}, '', newUrl);
            }

        function base64Decode(str) {
                return decodeURIComponent(escape(atob(str)));
            }

        function loadParamsFromBase64Url() {
                const urlParams = new URLSearchParams(window.location.search);
                const dataParam = urlParams.get('wxev');

                if (dataParam) {
                    try {
                        const decoded = base64Decode(dataParam);
                        const userId = decoded;
                        if (userId) {
                            localStorage.setItem('userId', userId);
                            //localStorage.setItem('appId', appId);
                            return userId ;
                        }
                    } catch (e) {
                        console.error('Invalid Base64 data:', e);
                    }
                }

                // fallback
                return 
                    localStorage.getItem('userId') || 'defaultUser';
            }

            //setBase64ParamsInUrl('kyhssKg');
            let appId = "timetableData"
            // Later in your app, decode from URL or localStorage
            const currentUserId= loadParamsFromBase64Url();
            const basePath = `${appId}/${currentUserId}`;
        

           // console.log(basePath);

        // Import Firebase modules directly
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, getDocs, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Firebase Variables ---
        const firebaseConfig = {
                        apiKey: "AIzaSyAu5TDMWepJX7naoG5H3WpGJ1yxAu01whg",
                        authDomain: "timetables-470dd.firebaseapp.com",
                        projectId: "timetables-470dd",
                        storageBucket: "timetables-470dd.firebasestorage.app",
                        messagingSenderId: "925422681424",
                        appId: "1:925422681424:web:df91ce9de4dfef9c5ec055",
                        measurementId: "G-N7ND4LPL9W"
                        };

        let db = null; 
        let auth = true;
        let userId = currentUserId ;
        let firebaseReadyPromise = null; // Promise to ensure Firebase is initialized and authenticated
           
       

        // --- Constants and Global Variables ---
       let DAYS = [];
let FULL_DAYS = [];
let NUM_PERIODS_PER_DAY = 7;

const SHORT_DAY_CODES = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
const FULL_DAY_NAMES = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

function saveToLocalStorage(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}

function getFromLocalStorage(key, fallback) {
  const stored = localStorage.getItem(key);
  return stored ? JSON.parse(stored) : fallback;
}

function updateScheduleSettings(save = true) {
  try {
    const daysInput = parseInt(document.getElementById("weeklyDays").value);
    const periodsInput = parseInt(document.getElementById("periodsPerDay").value);

    if (isNaN(daysInput) || daysInput < 1 || daysInput > 6) {
      throw new Error("Working days must be between 1 and 6.");
    }
    if (isNaN(periodsInput) || periodsInput < 1 || periodsInput > 10) {
      throw new Error("Periods per day must be between 1 and 10.");
    }

    // Animate inputs
    animateInput("weeklyDays");
    animateInput("periodsPerDay");
    animateInput("relaxiationPerDay");
      

    // Update values
    DAYS = SHORT_DAY_CODES.slice(0, daysInput);
    FULL_DAYS = FULL_DAY_NAMES.slice(0, daysInput);
    NUM_PERIODS_PER_DAY = periodsInput;

    if (save) {
      saveToLocalStorage(userId+"weeklyDays", daysInput);
      saveToLocalStorage(userId+"periodsPerDay", periodsInput);
    }

    console.log("DAYS:", DAYS);
    console.log("FULL_DAYS:", FULL_DAYS);
    console.log("NUM_PERIODS_PER_DAY:", NUM_PERIODS_PER_DAY);

  } catch (err) {
    alert("Error: " + err.message);
  }
}

function animateInput(id) {
  const el = document.getElementById(id);
  el.style.transition = "box-shadow 0.3s ease";
  el.style.boxShadow = "0 0 10px rgba(76, 175, 80, 0.6)";
  setTimeout(() => {
    el.style.boxShadow = "none";
  }, 400);
}

// Initialize from localStorage or defaults
function initializeSettings() {
  const storedDays = getFromLocalStorage(userId+"weeklyDays", 6);
  const storedPeriods = getFromLocalStorage(userId+"periodsPerDay", 7);

  document.getElementById("weeklyDays").value = storedDays;
  document.getElementById("periodsPerDay").value = storedPeriods;

  updateScheduleSettings(false); // initialize without re-saving
}

// Attach listeners
document.getElementById("weeklyDays").addEventListener("input", () => updateScheduleSettings());
document.getElementById("periodsPerDay").addEventListener("input", () => updateScheduleSettings());

// Run on load
initializeSettings();


        
        // Firestore Collection Paths (relative to user's base path)
        const FIRESTORE_COLLECTION_TIMETABLES = 'timetables';
        const FIRESTORE_COLLECTION_TEACHERS_DATA = 'teachersData';
        const FIRESTORE_COLLECTION_CLASS_DATA = 'classData';
        const FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE = 'unassignedSlots';
        
        // Local Storage Keys
        const LOCAL_STORAGE_KEY_TIMETABLE = userId+'timetableGenerator_timetable';
        const LOCAL_STORAGE_KEY_TEACHERS = userId+'timetableGenerator_teachersData'; 
        const LOCAL_STORAGE_KEY_UNASSIGNED = userId+'timetableGenerator_unassignedSlots';
        const LOCAL_STORAGE_KEY_SLOTS = userId+'timetableGenerator_Slots';
        
        // --- Global State Variables ---
        let teachers = {}; // Stores processed teacher data: { teacherId: { ...teacher_info, unavailable_slots: Set, daily_assignments: {day: []} } }
        let requiredSlots = []; // Stores the definition of all subject-hours needed: [{ class_name, subject, teacher_id, isClassCharge, slotNumber }]
        let importedTeachersRawData = []; // Stores the raw data from the imported file after processing
        let isDataImported = false; // Flag to track if data has been imported
        let areSlotsCreated = false; // Flag to track if slots have been created

        let currentTimetableData = {}; // Stores the actively displayed timetable: { slotKey: [{ class, subject, teacher_id, teacherName, day, period_num, isLocked, slotNumber }] }
        let currentUnassignedSlots = []; // Stores the actively displayed unassigned slots: [{ class_name, subject, teacher_id, isClassCharge, slotNumber }]
        
        // Click-to-Move State
        let activeMovingSlot = null; // The slot data currently selected for moving
        let originalSourceInfo = null; // Stores info about where the slot came from ({type: 'unassigned-card'|'timetable-cell', element: HTMLElement, ...})
        let movingElement = null; // The visual element following the mouse


        // Track the currently displayed timetable type and ID
        let currentMainTimetableDisplay = {
            type: 'none', // 'full' (management tab), 'teacher' (management tab), 'class' (management tab), 'none'
            id: null // Teacher ID or Class Name if type is 'teacher' or 'class'
        };

        // --- Undo/Redo Stacks ---
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK_SIZE = 20; // Limit the number of undoable actions

        // --- DOM Elements ---
        
        const relaxiation = document.getElementById('relaxiationPerDay');
        const fileInput = document.getElementById('file-input');
        const importButton = document.getElementById('import-button');
        const exportButton = document.getElementById('export-button');
        const exportToFirestoreButton = document.getElementById('export-to-firestore-button');
        const createSlotsButton = document.getElementById('create-slots-button');
        // const generateTimetableButton = document.getElementById('generate-timetable-button'); // Removed
        const downloadTemplateButton = document.getElementById('download-template');
        const regenerateButton = document.getElementById('regenerate-button');
        const clearSavedDataButton = document.getElementById('clear-saved-data-button');
        const clearAllAssignmentsButton = document.getElementById('clear-all-assignments-button'); // New
        const fillEmptySlotsButton = document.getElementById('fill-empty-slots-button');
        const undoButton = document.getElementById('undo-button'); // New
        const redoButton = document.getElementById('redo-button'); // New

        const timetableContainer = document.getElementById('timetable-container');
        const timetableTable = document.getElementById('timetable-table');
        const timetableTitle = document.getElementById('timetable-title');
        const messageBox = document.getElementById('message-box');
        const availableSlotsContainer = document.getElementById('available-slots-container');
        const noUnassignedMessage = document.getElementById('no-unassigned-message');
        const userIdDisplay = document.getElementById('user-id-display');
        const loadingOverlay = document.getElementById('loading-overlay');

        const headerModal = document.getElementById("header-modal");
        const modalClose = document.querySelector("#header-modal .close");
        const selectFileButton = document.getElementById("select-file-button");

        const demoDataRadio = document.getElementById('demo-data-radio');
        const originalDataRadio = document.getElementById('original-data-radio');

        // Elements for "Timetable Management" tab (editable views)
        const teacherDropdownEditable = document.getElementById('teacher-dropdown-editable');
        const classDropdownEditable = document.getElementById('class-dropdown-editable');
        const viewTeacherTimetableEditableButton = document.getElementById('view-teacher-timetable-editable-button');
        const viewClassTimetableEditableButton = document.getElementById('view-class-timetable-editable-button');
        const viewAllTimetableButton = document.getElementById('view-all-timetable-button');
        const individualTimetableDisplay = document.getElementById('individual-timetable-display'); // New container for editable individual views
        const individualTimetableTable = document.getElementById('individual-timetable-table');
        const individualTimetableTitle = document.getElementById('individual-timetable-title');

        // Tab elements
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Report table elements
        const teacherReportTableBody = document.querySelector('#teacher-report-table tbody');
        const teacherReportTableFoot = document.querySelector('#teacher-report-table tfoot'); // New
        const classReportTableBody = document.querySelector('#class-report-table tbody');
        const classReportTableFoot = document.querySelector('#class-report-table tfoot'); // New

        // Print Buttons (now only in Reports tab)
        
        const printAllTeacherTimetablesButton = document.getElementById('print-all-teacher-timetables-button');
        const printTeacherReportButton = document.getElementById('print-teacher-report-button');
        const printClassReportButton = document.getElementById('printclassreport-button');
        const printAllClassTimetablesButton = document.getElementById('print-all-class-timetables-button');
        
        // Custom Context Menu elements
        const customContextMenu = document.getElementById('custom-context-menu');
        const lockUnlockOption = document.getElementById('lock-unlock-option');
        const unassignSlotOption = document.getElementById('unassign-slot-option');
        let contextMenuTargetCell = null; // Stores the cell that was right-clicked


        // Unassigned slot filter elements
        const filterUnassignedClassDropdown = classDropdownEditable;// document.getElementById('filter-unassigned-class-dropdown');
        const filterUnassignedTeacherDropdown = teacherDropdownEditable; //document.getElementById('filter-unassigned-teacher-dropdown');
        const clearUnassignedFiltersButton = document.getElementById('clear-unassigned-filters-button');


        // --- Utility Functions ---

        /**
         * Displays a temporary message box.
         * @param {string} message - The message to display.
         * @param {'success'|'error'|'info'} type - The type of message (determines color).
         */
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = `fixed top-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded shadow-md z-100 show ${
                type === 'success' ? 'bg-green-100 text-green-700 border border-green-400' : 
                type === 'error' ? 'bg-red-100 text-red-700 border border-red-400' :
                'bg-blue-100 text-blue-700 border border-blue-400' // 'info' type
            }`;
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3500); // Increased duration slightly
        }

        /**
         * Shows the loading overlay.
         * @param {string} message - Optional message to display.
         */
        function showLoading(message = 'Loading...') {
            loadingOverlay.querySelector('p').textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        /**
         * Hides the loading overlay.
         */
        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        /**
         * Initializes Firebase and handles user authentication.
         * Uses __firebase_config and __initial_auth_token from the environment.
         */
        async function initializeFirebaseAndAuth() {
            
                console.log("Firebase Config being used:", firebaseConfig); 
                //console.log(getApp().firebaseConfig.projectId);


                if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey || !firebaseConfig.projectId || !firebaseConfig.authDomain) {
                    console.error("Firebase config is missing or incomplete.");
                    showMessage("Firebase configuration missing or incomplete. Cannot connect to database. Please check your config.", "error");
                    return;
                }

                    firebaseReadyPromise = new Promise(async (resolve) => {
                try {
                    // Access global variables provided by the environment
                   // const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;
                    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                    const appIdFromEnv = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

                    if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                        console.error("Firebase config is missing or incomplete. Cannot connect to database.");
                        showMessage("Firebase configuration missing or incomplete. Cannot connect to database.", "error");
                        resolve(false);
                        return;
                    }

                    const firebaseApp = initializeApp(firebaseConfig);

                    db = getFirestore(firebaseApp);
                    showMessage("Firebase connected and authenticated!", "success");
                    auth = getAuth(firebaseApp);
                    resolve(true); // Firebase is ready and authenticated
                    // onAuthStateChanged(auth, async (user) => {
                    //     if (user) {
                    //         userId = user.uid;
                    //         userIdDisplay.textContent = userId;
                    //         console.log("Firebase: User authenticated. UID:", userId);
                    //         showMessage("Firebase connected and authenticated!", "success");
                    //         resolve(true); // Firebase is ready and authenticated
                    //     } else {
                    //         // If no user is logged in, try to sign in with custom token or anonymously
                    //         try {
                    //             if (initialAuthToken) {
                    //                 await signInWithCustomToken(auth, initialAuthToken);
                    //             } else {
                    //                 await signInAnonymously(auth);
                    //             }
                    //         } catch (anonError) {
                    //             console.error("Firebase: Anonymous sign-in failed:", anonError);
                    //             showMessage(`Firebase Auth Error: ${anonError.message}`, "error");
                    //             userId = crypto.randomUUID(); // Fallback to a random ID if auth fails
                    //             userIdDisplay.textContent = userId + " (Anonymous/Local)";
                    //             resolve(false); // Firebase ready, but auth failed
                    //         }
                    //     }
                    // });

                } catch (error) {
                    console.error("Error initializing Firebase:", error);
                    showMessage(`Firebase Initialization Error: ${error.message}`, "error");
                    resolve(false); // Firebase initialization failed
                }
            });
        }
        
        // Call Firebase initialization immediately
        initializeFirebaseAndAuth();

        /**
         * Constructs the base path for Firestore documents, adhering to security rules.
         * @returns {string} The base path for the current user's data.
         */
        function getFirestoreBasePath() {
            const appId = "timetableData";//typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // Use the authenticated userId if available, otherwise a default/random one
            //const currentUserId = userId || crypto.randomUUID(); // Ensure userId is populated
            return `${appId}/${currentUserId}`;
        }

        /**
         * Updates the enabled/disabled state of action buttons.
         */
        function updateButtonStates() {
            createSlotsButton.disabled = !(isDataImported || demoDataRadio.checked);
            exportButton.disabled = Object.keys(currentTimetableData).length === 0;
            exportToFirestoreButton.disabled = Object.keys(currentTimetableData).length === 0 || !db; // Also disable if Firestore not ready
            regenerateButton.disabled = !areSlotsCreated;
            clearSavedDataButton.disabled = !localStorage.getItem(LOCAL_STORAGE_KEY_TIMETABLE) && !localStorage.getItem(LOCAL_STORAGE_KEY_UNASSIGNED) && !localStorage.getItem(LOCAL_STORAGE_KEY_TEACHERS) && !localStorage.getItem(LOCAL_STORAGE_KEY_SLOTS) && Object.keys(teachers).length === 0;
            clearAllAssignmentsButton.disabled = Object.keys(currentTimetableData).length === 0;
            fillEmptySlotsButton.disabled = currentUnassignedSlots.length === 0;
            undoButton.disabled = undoStack.length === 0; // Enable/disable Undo button
            redoButton.disabled = redoStack.length === 0; // Enable/disable Redo button


            const hasTeachers = Object.keys(teachers).length > 0;
            const hasTimetable = areSlotsCreated && Object.keys(currentTimetableData).length > 0;

            // Management Tab Buttons
            viewAllTimetableButton.disabled = !areSlotsCreated;
            teacherDropdownEditable.disabled = !hasTeachers;
            classDropdownEditable.disabled = !hasTeachers;
            viewTeacherTimetableEditableButton.disabled = !hasTimetable || !teacherDropdownEditable.value;
            viewClassTimetableEditableButton.disabled = !hasTimetable || !classDropdownEditable.value;

            // Report Tab Buttons (Print buttons)
            printAllTeacherTimetablesButton.disabled = !hasTimetable;
            printAllClassTimetablesButton.disabled = !hasTimetable;

            // Unassigned slot filters
            filterUnassignedClassDropdown.disabled = !hasTeachers;
            filterUnassignedTeacherDropdown.disabled = !hasTeachers;
            clearUnassignedFiltersButton.disabled = (!filterUnassignedClassDropdown.value && !filterUnassignedTeacherDropdown.value);
        }

        /**
         * Helper to check if a slot (identified by its unique properties) is already present in the currentUnassignedSlots array.
         * @param {Object} slot - The slot object to check.
         * @returns {boolean} True if the slot is found, false otherwise.
         */
        function isSlotInUnassigned(slot) {
            return currentUnassignedSlots.some(s =>
                s.class_name === slot.class_name &&
                s.subject === slot.subject &&
                s.teacher_id === slot.teacher_id &&
                s.slotNumber === slot.slotNumber
            );
        }
        function isSlotInRequired(slot) {
            return requiredSlots.some(s =>
                s.class_name === slot.class_name &&
                s.subject === slot.subject &&
                s.teacher_id === slot.teacher_id &&
                s.slotNumber === slot.slotNumber
            );
        }

        /**
         * Adds a slot to the currentUnassignedSlots array, ensuring no duplicates based on unique slot properties.
         * Sets isLocked to false for any slot added to unassigned.
         * @param {Object} slot - The slot object to add.
         */
        function addUniqueUnassignedSlot(slot) {
            if (!isSlotInUnassigned(slot) && isSlotInRequired(slot) ) {
                currentUnassignedSlots.push({ ...slot, isLocked: false }); // Ensure it's unlocked when unassigned
            }
        }

        /**
         * Displays available (unassigned) slots and attaches click listeners.
         * @param {Array<Object>} slots - Array of unassigned slot objects.
         * @param {string|null} filterClass - Optional class name to filter by.
         * @param {string|null} filterTeacher - Optional teacher ID to filter by.
         */
        function displayUnassignedSlots(slots, filterClass = null, filterTeacher = null) {
            const currentActiveTab = document.querySelector('.tab-button.active').dataset.tab;
            
            // Unassigned slots are only displayed when on the "Timetable Management" tab
            if (currentActiveTab === 'timetable-management-tab') {
                availableSlotsContainer.classList.remove('hidden');
                availableSlotsContainer.innerHTML = '<h3 class="text-lg font-semibold text-gray-700 mb-2">Unassigned Slots: <span class="text-sm text-gray-500">(Click a slot to assign it manually)</span></h3>';
                
                // Apply filters
                let filteredSlots = slots;
                if (filterClass) {
                    filteredSlots = filteredSlots.filter(s => s.class_name === filterClass);
                }
                if (filterTeacher) {
                    filteredSlots = filteredSlots.filter(s => s.teacher_id === filterTeacher);
                }

                if (filteredSlots.length === 0) {
                    availableSlotsContainer.appendChild(noUnassignedMessage);
                    noUnassignedMessage.classList.remove('hidden');
                } else {
                    noUnassignedMessage.classList.add('hidden');
                    filteredSlots.forEach((slot, index) => {
                        const slotCard = document.createElement('div');
                        slotCard.className = 'slot-card';
                        // Ensure class_name is always present for display
                        slotCard.textContent = `${slot.class_name || ''} - ${slot.subject}${slot.slotNumber ? '-' + slot.slotNumber : ''} (${teachers[slot.teacher_id]?.teacherName || 'N/A'})`;
                        // Store the actual slot object (or a copy) directly, not just the index
                        slotCard.dataset.slotData = JSON.stringify(slot); 

                        // Attach click listener to select slot
                        slotCard.addEventListener('click', (e) => {
                            const clickedSlotData = JSON.parse(e.currentTarget.dataset.slotData);
                            selectSlotForMove(clickedSlotData, { type: 'unassigned-card', element: e.currentTarget }, e);
                        });
                        availableSlotsContainer.appendChild(slotCard);
                    });
                }
            } else {
                availableSlotsContainer.classList.add('hidden'); // Hide unassigned slots for other tabs
            }
            saveTimetable(); // Save timetable after updating unassigned slots
        }

        /**
         * Renders/updates the timetable table in the specified display area.
         * @param {Object} assignedData - The object containing assigned slots keyed by day+period (e.g., Mo1).
         * @param {string} viewType - 'full', 'teacher', or 'class'
         * @param {string|null} viewId - Teacher ID or Class Name for individual views
         * @param {HTMLElement} targetTable - The <table> element to render into (e.g., timetableTable or individualTimetableTable)
         * @param {HTMLElement} targetTitle - The <h2> element for the title
         * @param {HTMLElement} targetContainer - The container div to show/hide
         * @param {boolean} isEditable - True if cells should have click/contextmenu listeners, false for read-only.
         */
        function renderSecondaryMiniTimetable(type, id) {
  const secondaryTable = document.getElementById('secondary-timetable-table');
  const secondaryTitle = document.getElementById('secondary-timetable-title');
  const secondaryContainer = document.getElementById('secondary-timetable-display');

  const dataToUse = {};
  for (const slotKey in currentTimetableData) {
    const assignments = currentTimetableData[slotKey] || [];
    const filtered = assignments.filter(a => a && a[type] === id);
    if (filtered.length > 0) {
      dataToUse[slotKey] = filtered;
    }
  }

  if (type === 'teacher_id') {
    const teacher = teachers[id];
    console.log(teachers);
    if (!teacher) return;
    secondaryTitle.textContent = `Mini View: ${teacher.teacherName}'s Timetable`;
    renderTimetable(dataToUse, 'teacher', id, secondaryTable, secondaryTitle, secondaryContainer, false);
  } else if (type === 'class') {
    secondaryTitle.textContent = `Mini View: Class ${id} Timetable`;
    renderTimetable(dataToUse, 'class', id, secondaryTable, secondaryTitle, secondaryContainer, false);
  }

  secondaryContainer.classList.remove('hidden');
}

function renderMiniTimetablePopup(type, id,name) {
    const popupId = `mini-popup-${type}-${id}`;
    let popup = document.getElementById(popupId);

    // Close older unpinned popups if more than 2 are open
    const unpinnedPopups = Array.from(document.querySelectorAll('.mini-popup'))
        .filter(p => p.dataset.pinned !== 'true');
    
    if (unpinnedPopups.length >= 2) {
        unpinnedPopups.forEach(p => p.remove());
    }

    if (!popup) {
        popup = document.createElement('div');
        popup.id = popupId;
        popup.className = 'mini-popup';
        popup.dataset.pinned = 'false';

        popup.innerHTML = `
            <div class="mini-popup-header" style="cursor: move; background: #eee; padding: 5px;">
                <strong>${type === "teacher_id" ? "Teacher"+name : "Class"+id}</strong>
                <button class="pin-btn" title="Pin" style="float:right;margin-left:4px;">📌</button>
                <button class="close-mini-popup" title="Close" style="float:right;">&times;</button>
            </div>
            <div class="mini-popup-body">${renderMiniTimetableContent(type, id,name)}</div>
            <div class="resize-handle" style="position:absolute;right:0;bottom:0;width:15px;height:15px;cursor:se-resize;"></div>
        `;

        document.body.appendChild(popup);

        makeDraggable(popup);
        makeResizable(popup);

        popup.querySelector('.close-mini-popup').addEventListener('click', () => popup.remove());

        popup.querySelector('.pin-btn').addEventListener('click', () => {
            const isPinned = popup.dataset.pinned === 'true';
            popup.dataset.pinned = (!isPinned).toString();
            popup.classList.toggle('pinned', !isPinned);
        });
    }

    // Position left/right based on current unpinned count
    const positionOffset = document.querySelectorAll('.mini-popup').length % 2 === 0 ? '100px' : '';
    popup.style.position = 'fixed';
    popup.style.top = '6px';
    popup.style.left = positionOffset;
    popup.style.right = positionOffset === '' ? '100px' : '';
    popup.style.width = '400px';
    popup.style.zIndex = 1000;
    popup.style.display = 'block';
}


// Optional: Call this periodically or on mouse leave to close popups
function closeUnpinnedPopups() {
    document.querySelectorAll('.mini-popup').forEach(popup => {
        if (popup.dataset.pinned !== 'true') {
            setTimeout(() => popup.remove(), 300);
        }
    });
}


function makeDraggable(popup) {
    const header = popup.querySelector('.mini-popup-header');
    let offsetX = 0, offsetY = 0, isDragging = false, hasMoved = false;

    header.addEventListener('mousedown', (e) => {
        const rect = popup.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        isDragging = true;
        hasMoved = false;

        function onMouseMove(e) {
            if (!isDragging) return;
            hasMoved = true;
            popup.style.left = `${e.clientX - offsetX}px`;
            popup.style.top = `${e.clientY - offsetY}px`;
            popup.style.position = 'fixed';
        }

        function onMouseUp() {
            if (isDragging && hasMoved) {
                popup.dataset.pinned = 'true';
                popup.classList.add('pinned');
            }
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
}



// Helper to make popup resizable
function makeResizable(popup) {
    const handle = popup.querySelector('.resize-handle');
    let isResizing = false;

    handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isResizing = true;

        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = popup.offsetWidth;
        const startHeight = popup.offsetHeight;

        function doDrag(e) {
            if (!isResizing) return;
            popup.style.width = `${startWidth + e.clientX - startX}px`;
            popup.style.height = `${startHeight + e.clientY - startY}px`;
        }

        function stopDrag() {
            isResizing = false;
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
    });
}

function renderMiniTimetableContent(type, id,name) {
  const dataToUse = {};

  // Filter relevant slots for the teacher/subject/class etc.
  for (const slotKey in currentTimetableData) {
    const assignments = currentTimetableData[slotKey] || [];
    const matches = assignments.filter(a => a && a[type] === id);
    if (matches.length > 0) {
      dataToUse[slotKey] = matches[0]; // Assuming only one per slot
    }
  }

  // Start building the timetable HTML
  let html = ``;//<div style="margin-bottom:5px;"><strong>${type.toUpperCase()}: ${type==="class"? id:name}</strong></div>
  html += `<table style="border-collapse: collapse; width: 100%; font-size: 13px;">
            <thead>
              <tr>
                <th style="border: 1px solid #ccc; padding: 4px;">Day</th>`;

  // Period headers
  for (let p = 1; p <= NUM_PERIODS_PER_DAY; p++) {
    html += `<th style="border: 1px solid #ccc; padding: 4px;">P${p}</th>`;
  }
  html += `</tr></thead><tbody>`;

  // Rows per day
  DAYS.forEach(day => {
    html += `<tr><td style="border: 1px solid #ccc; padding: 4px;"><strong>${day}</strong></td>`;
    for (let p = 1; p <= NUM_PERIODS_PER_DAY; p++) {
      const slotKey = `${day}${p}`;
      const assignment = dataToUse[slotKey];
      html += `<td style="border: 1px solid #ccc; padding: 4px; text-align: center;">   ${type==="class"? assignment ?  assignment.teacherName : '-':assignment ?  assignment.class : '-'}</td>`;
    }
    html += '</tr>';
  });

  html += `</tbody></table>`;
  return html;
}



        function renderTimetable(assignedData, viewType, viewId, targetTable, targetTitle, targetContainer, isEditable = true) {
            targetContainer.classList.remove('hidden'); // Ensure container is visible
            document.getElementById('secondary-timetable-display').classList.add('hidden');

            const thead = targetTable.querySelector('thead');
            const tbody = targetTable.querySelector('tbody');
            thead.innerHTML = ''; // Clear previous headers
            tbody.innerHTML = ''; // Clear the table body first

            // Clear all view-specific classes
            targetTable.classList.remove('all-view', 'individual-view');

            let headersRow;

            // --- Determine View Type and Set Table Class ---
            if (viewType === 'full') {
                targetTable.classList.add('all-view');
                targetTitle.textContent = 'Full School Timetable (Editable)';

                // Full View Headers
                headersRow = thead.insertRow();
                headersRow.insertCell().textContent = 'Teacher ID';
                headersRow.insertCell().textContent = 'Teacher Name';
                headersRow.insertCell().textContent = 'Class In Charge';
                for (const day of DAYS) {
                    for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                        headersRow.insertCell().textContent = `${day}${period}`;
                    }
                }

                // Full View Rows: Each teacher gets a row, sorted by teacher name
                const sortedTeachers = Object.values(teachers).sort((a,b) => a.teacherName.localeCompare(b.teacherName));

                sortedTeachers.forEach(teacher => {
                    let row = tbody.insertRow(); // Create a new row in the tbody
                    row.dataset.teacherId = teacher.teacher_id;

                    row.insertCell().textContent = teacher.teacher_id;
                    row.insertCell().textContent = teacher.teacherName;
                    row.insertCell().textContent = teacher.classInCharge;

                    for (const day of DAYS) {
                        for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                            const slotKey = `${day}${period}`;
                            const cell = row.insertCell();
                            cell.dataset.slotKey = slotKey;
                            cell.dataset.teacherId = teacher.teacher_id; // Add teacherId to cell for easier lookup
                            
                            if (isEditable) {
                                cell.addEventListener('click', (e) => {
                                    if (activeMovingSlot) {
                                        // If a slot is currently being moved, attempt to place it here
                                        attemptPlaceSlot(cell, e); // Pass the event
                                    } else {
                                        // If no slot is being moved, select this one to move
                                        const assignmentInCell = currentTimetableData[slotKey]?.find(a => a && a.teacher_id === teacher.teacher_id);
                                        // Only select if there's an actual assignment or if it's an unassigned card
                                        if (assignmentInCell) {
                                            selectSlotForMove(assignmentInCell, { type: 'timetable-cell', element: cell, slotKey: slotKey, teacherId: teacher.teacher_id, class: assignmentInCell?.class, subject: assignmentInCell?.subject, slotNumber: assignmentInCell?.slotNumber }, e);
                                        }
                                    }
                                });
                                cell.addEventListener('contextmenu', handleContextMenu); // Add context menu listener
                            }

                            const assignmentsInThisPeriod = assignedData[slotKey] || [];
                            const assignmentForThisTeacher = assignmentsInThisPeriod.find(a => a && a.teacher_id === teacher.teacher_id);
                            const isTeacherUnavailable = teacher.unavailable_slots.has(slotKey);

                            if (assignmentForThisTeacher) {
                                // Ensure class is displayed if available, otherwise just subject
                                const classDisplay = assignmentForThisTeacher.class ? `${assignmentForThisTeacher.class} - ` : '';
                                cell.textContent = `${classDisplay}${assignmentForThisTeacher.subject}${assignmentForThisTeacher.slotNumber ? '-' + assignmentForThisTeacher.slotNumber : ''}`;
                                if (assignmentForThisTeacher.isLocked) {
                                    cell.classList.add('locked-cell');
                                    cell.innerHTML += ' &#128274;'; // Unicode lock emoji
                                } else {
                                    cell.classList.remove('locked-cell');
                                }
                            } else if (isTeacherUnavailable) {
                                cell.textContent = 'Unavailable';
                                cell.classList.remove('locked-cell'); // Ensure no lock on unavailable
                            } else {
                                cell.textContent = ''; // Clear content if empty
                                cell.classList.remove('locked-cell');
                            }
                        }
                    }
                });

            } else if (viewType === 'teacher') {
               targetTable.classList.add('individual-view');
                const teacher = teachers[viewId];
                console.log(teacher);
                targetTitle.textContent = `Timetable for ${teacher?.teacherName || 'N/A'}-${teacher?.classInCharge} (${viewId}) ${isEditable ? '(Editable)' : '(Read-Only)'}`;

                // Teacher View Headers: Day, P1, P2, ... P7
                headersRow = thead.insertRow();
                headersRow.insertCell().textContent = 'Day';
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                    headersRow.insertCell().textContent = `P${period}`;
                }

                // Teacher View Rows: Each day gets a row
                DAYS.forEach((day, index) => {
                    const row = tbody.insertRow();
                    row.insertCell().textContent = FULL_DAYS[index]; // Full day name

                    for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) { // Corrected loop condition
                        const slotKey = `${day}${period}`;
                        const cell = row.insertCell();
                        cell.dataset.slotKey = slotKey;
                        cell.dataset.teacherId = viewId; // Explicitly set teacherId for the cell
                        
                        if (isEditable) {
                            cell.addEventListener('click', (e) => {
                                console.log(cell.dataset);
                                // renderSecondaryMiniTimetable('class', cell.data.class);
                                if (activeMovingSlot) {
                                    attemptPlaceSlot(cell, e); // Pass the event
                                } else {
                                    const assignmentInCell = currentTimetableData[slotKey]?.find(a => a && a.teacher_id === viewId);
                                   console.log(assignmentInCell);
                                    if (assignmentInCell) {
                                        renderSecondaryMiniTimetable('class',assignmentInCell?.class);
                                        selectSlotForMove(assignmentInCell, { type: 'timetable-cell', element: cell, slotKey: slotKey, teacherId: viewId, class: assignmentInCell?.class, subject: assignmentInCell?.subject, slotNumber: assignmentInCell?.slotNumber }, e);
                                    }
                                }
                            });
                            cell.addEventListener('contextmenu', handleContextMenu); // Add context menu listener
                            // 👉 Show mini timetable on hover
                       let hoverTimer;

                        cell.addEventListener('mouseenter', (e) => {
                            hoverTimer = setTimeout(() => {
                                
                                const assignment = currentTimetableData[slotKey]?.find(a => a && a.teacher_id === viewId);
                                if (assignment && assignment.class) {
                                    renderMiniTimetablePopup("class", assignment.class , e.target);
                                    renderMiniTimetablePopup("teacher_id", assignment.teacher_id, assignment.teacherName,e.target);
                                }
                            }, 1000); // 1 second delay
                        });

                        cell.addEventListener('mouseleave', () => {
                            clearTimeout(hoverTimer); // Cancel if mouse leaves early
                        });
                        
                        }

                        const assignmentsInThisPeriod = assignedData[slotKey] || [];
                        const assignmentForThisTeacher = assignmentsInThisPeriod.find(a => a && a.teacher_id === viewId);
                        const isTeacherUnavailable = teacher.unavailable_slots.has(slotKey);

                        if (assignmentForThisTeacher) {
                             // Ensure class is displayed if available, otherwise just subject
                            const classDisplay = assignmentForThisTeacher.class ? `${assignmentForThisTeacher.class} - ` : '';
                            cell.textContent = `${classDisplay}${assignmentForThisTeacher.subject}${assignmentForThisTeacher.slotNumber ? '-' + assignmentForThisTeacher.slotNumber : ''}`;
                            if (assignmentForThisTeacher.isLocked) {
                                cell.classList.add('locked-cell');
                                cell.innerHTML += ' &#128274;'; // Unicode lock emoji
                            } else {
                                cell.classList.remove('locked-cell');
                            }
                        } else if (isTeacherUnavailable) {
                            cell.textContent = 'Unavailable';
                            cell.classList.remove('locked-cell');
                        } else {
                            cell.textContent = '';
                            cell.classList.remove('locked-cell');
                        }
                    }
                });


            } else if (viewType === 'class') {
                targetTable.classList.add('individual-view');
                targetTitle.textContent = `Timetable for Class ${viewId} ${isEditable ? '(Editable)' : '(Read-Only)'}`;

                // Class View Headers: Day, P1, P2, ... P7
                headersRow = thead.insertRow(); // Corrected: Use insertRow() on thead
                headersRow.insertCell().textContent = 'Day';
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                    headersRow.insertCell().textContent = `P${period}`;
                }

                // Class View Rows: Each day gets a row
                DAYS.forEach((day, index) => {
                    const row = tbody.insertRow(); // Corrected: Use insertRow() on tbody
                    row.insertCell().textContent = FULL_DAYS[index]; // Full day name

                    for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) { // Corrected loop condition
                        const slotKey = `${day}${period}`;
                        const cell = row.insertCell();
                        cell.dataset.slotKey = slotKey;
                        cell.dataset.className = viewId; // Explicitly set className for the cell
                        
                        if (isEditable) {
                            cell.addEventListener('click', (e) => {
                                if (activeMovingSlot) {
                                    attemptPlaceSlot(cell, e); // Pass the event
                                } else {
                                    const assignmentInCell = currentTimetableData[slotKey]?.find(a => a && a.class === viewId);
                                    //console.log(assignmentInCell);
                                    if (assignmentInCell) {
                                        
                                        selectSlotForMove(assignmentInCell, { type: 'timetable-cell', element: cell, slotKey: slotKey, class: viewId, teacherId: assignmentInCell?.teacher_id, subject: assignmentInCell?.subject, slotNumber: assignmentInCell?.slotNumber }, e);
                                        renderSecondaryMiniTimetable('teacher_id', assignmentInCell.teacher_id);
                                        
                                    }
                                }
                            });
                            cell.addEventListener('contextmenu', handleContextMenu); // Add context menu listener
                        
                            // 👉 Show mini timetable on hover
                       let hoverTimer;

                        cell.addEventListener('mouseenter', (e) => {
                            hoverTimer = setTimeout(() => {
                                
                                const assignment = currentTimetableData[slotKey]?.find(a => a && a.class === viewId);
                                if (assignment && assignment.teacher_id) {
                                    renderMiniTimetablePopup("teacher_id", assignment.teacher_id,assignment.teacherName, e.target);
                                    renderMiniTimetablePopup("class", assignment.class , e.target);
                                
                                }
                            }, 1000); // 1 second delay
                        });

                        cell.addEventListener('mouseleave', () => {
                            clearTimeout(hoverTimer); // Cancel if mouse leaves early
                        });
                        
                        
                        }

                        const assignmentsInThisPeriod = assignedData[slotKey] || [];
                        const assignmentForThisClass = assignmentsInThisPeriod.find(a => a && a.class === viewId);

                        if (assignmentForThisClass) {
                            cell.textContent = `${assignmentForThisClass.subject}${assignmentForThisClass.slotNumber ? '-' + assignmentForThisClass.slotNumber : ''} (Teacher: ${assignmentForThisClass.teacherName})`;
                            if (assignmentForThisClass.isLocked) {
                                cell.classList.add('locked-cell');
                                cell.innerHTML += ' &#128274;'; // Unicode lock emoji
                            } else {
                                cell.classList.remove('locked-cell');
                            }
                        } else {
                            cell.textContent = '';
                            cell.classList.remove('locked-cell');
                        }
                    }
                });
            }
            
            updateButtonStates();
        }

        /**
         * Displays the full timetable (editable).
         */
        function displayFullTimetable() {
            currentMainTimetableDisplay.type = 'full';
            currentMainTimetableDisplay.id = null;
            renderTimetable(currentTimetableData, 'full', null, timetableTable, timetableTitle, timetableContainer, true);
            displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value); // Show unassigned slots for manual assignment
            clearHighlights(); // Clear highlights when switching view
            cancelMovingSlot(); // Deselect any selected slot
            // Hide the individual timetable display
            individualTimetableDisplay.classList.add('hidden');
        }

        /**
         * Filters and displays the timetable for a specific teacher in the 'individual-timetable-display' div (editable).
         * @param {string} teacherId - The ID of the teacher.
         */
        function displayTeacherTimetableEditable(teacherId) {
            const teacher = teachers[teacherId];
            if (!teacher) {
                showMessage('Teacher not found.', 'error');
                return;
            }

            const filteredTimetableData = {};
            for (const slotKey in currentTimetableData) {
                const assignments = currentTimetableData[slotKey] || [];
                // Filter the assignments for the selected teacher
                const teacherAssignment = assignments.find(a => a && a.teacher_id === teacherId);
                if (teacherAssignment) {
                    filteredTimetableData[slotKey] = [teacherAssignment]; // Wrap in array for consistency
                }
            }
            currentMainTimetableDisplay.type = 'teacher';
            currentMainTimetableDisplay.id = teacherId;
           
            renderTimetable(filteredTimetableData, 'teacher', teacherId, individualTimetableTable, individualTimetableTitle, individualTimetableDisplay, true);
            // Hide full timetable and unassigned slots for this view
             displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value); // Show unassigned slots for manual assignment
           
            timetableContainer.classList.add('hidden');
            availableSlotsContainer.classList.add('hidden');
            clearHighlights();
            cancelMovingSlot();
        }

        /**
        * Filters and displays the timetable for a specific class in the 'individual-timetable-display' div (editable).
        * @param {string} className - The name of the class.
        */
        function displayClassTimetableEditable(className) {
            const filteredTimetableData = {};
            for (const slotKey in currentTimetableData) {
                const assignments = currentTimetableData[slotKey] || [];
                // Filter the assignments for the selected class
                const classAssignments = assignments.filter(a => a && a.class === className);
                console.log(classAssignments); 

                if (classAssignments.length > 0) {
                    filteredTimetableData[slotKey] = classAssignments;
                }
            }
            currentMainTimetableDisplay.type = 'class';
            currentMainTimetableDisplay.id = className;
            renderTimetable(filteredTimetableData, 'class', className, individualTimetableTable, individualTimetableTitle, individualTimetableDisplay, true);
            
             displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value , filterUnassignedTeacherDropdown.value); // Show unassigned slots for manual assignment
           
            timetableContainer.classList.add('hidden');
            availableSlotsContainer.classList.add('hidden');
            clearHighlights();
            cancelMovingSlot();
        }


        // --- Conflict Checking and Highlighting ---

        /**
         * Checks if placing a slot in a specific cell would cause conflicts.
         * @param {string} teacherId - The ID of the teacher for the slot.
         * @param {string} day - The day (e.g., 'Mo').
         * @param {number} period_num - The period number (e.g., 1).
         * @param {string} className - The class name for the subject being placed.
         * @param {Object} currentTimetable - The current state of the timetable (assigned data).
         * @param {Object|null} slotBeingMoved - The slot that is currently being moved (to exclude it from conflict checks).
         * @returns {{isHardConflict: boolean, isSoftConflict: boolean, conflictingAssignment: Object|null}} Conflict details.
         */
        function checkConflicts(teacherId, day, period_num, className, currentTimetable, slotBeingMoved = null) {
            const slotKey = `${day}${period_num}`;
            const teacher = teachers[teacherId];

            if (!teacher) {
                console.error(`Conflict check: Teacher data missing for ID: ${teacherId}`);
                return { isHardConflict: true, isSoftConflict: false, conflictingAssignment: null };
            }

            const assignmentsInThisPeriod = currentTimetable[slotKey] || [];

            // Filter out the slot being moved if it's already in this cell (for accurate conflict checking during drag/drop)
            const relevantAssignmentsInPeriod = assignmentsInThisPeriod.filter(assignment =>
                !(slotBeingMoved &&
                  assignment.teacher_id === slotBeingMoved.teacher_id &&
                  assignment.class === (slotBeingMoved.class || slotBeingMoved.class_name) &&
                  assignment.subject === slotBeingMoved.subject &&
                  assignment.slotNumber === slotBeingMoved.slotNumber)
            );

            // Hard Conflict 1: Teacher unavailable for this slot
            if (teacher.unavailable_slots.has(slotKey)) {
                return { isHardConflict: true, isSoftConflict: false, conflictingAssignment: null };
            }

            let isClassConflict = false; // Only class conflict can be soft now
            let conflictingAssignment = null; // Store one of the conflicting assignments

            for (const assignment of relevantAssignmentsInPeriod) {
                if (!assignment) continue;

                // HARD CONFLICT 2: The specific teacher is already assigned to *any* slot in this period.
                // A teacher cannot teach two different subjects/classes at the same time.
                if (assignment.teacher_id === teacherId) {
                    return { isHardConflict: true, isSoftConflict: false, conflictingAssignment: assignment };
                }

                // SOFT CONFLICT: The class (className) is already assigned to this slot by a different teacher.
                // This is a soft conflict because a class might be split, or it's a warning.
                if (assignment.class === className) {
                    isClassConflict = true;
                    if (!conflictingAssignment) conflictingAssignment = assignment; // Store one of the conflicting assignments
                }
            }

            // Conflict 4: Max daily hours for teacher (e.g., 6 periods per day)
            // Count existing assignments for the teacher on this day, considering all periods for that teacher
            const maxDailyHours = 7; // Example constraint
            let currentDailyAssignmentsCount = 0;
            for (let p = 1; p <= NUM_PERIODS_PER_DAY; p++) {
                const currentSlotKey = `${day}${p}`;
                const assignments = currentTimetable[currentSlotKey] || [];
                // Filter out the slot being moved from this count as well
                const teacherAssignments = assignments.filter(a => a && a.teacher_id === teacherId && !(slotBeingMoved && a.slotNumber === slotBeingMoved.slotNumber && a.teacher_id === slotBeingMoved.teacher_id));
                currentDailyAssignmentsCount += teacherAssignments.length;
            }
            // If adding this new slot would exceed the daily limit
            if (currentDailyAssignmentsCount >= maxDailyHours) {
                return { isHardConflict: true, isSoftConflict: false, conflictingAssignment: null };
            }


            // Conflict 5: Max consecutive hours for teacher (e.g., max 3 consecutive)
            // Collect all assignments for this teacher on this day, including the potential new one
            let existingDayAssignments = [];
            for (let p = 1; p <= NUM_PERIODS_PER_DAY; p++) {
                const currentSlotKey = `${day}${p}`;
                const assignments = currentTimetable[currentSlotKey] || [];
                // Filter out the slot being moved from this check
                const assignedToTeacher = assignments.find(a => a && a.teacher_id === teacherId && !(slotBeingMoved && a.slotNumber === slotBeingMoved.slotNumber && a.teacher_id === slotBeingMoved.teacher_id));

                if (assignedToTeacher) {
                    // If it's an existing assignment, add its period number
                    existingDayAssignments.push(p);
                }
            }
            // Add the period of the slot we are trying to place
            existingDayAssignments.push(period_num);

            // Sort and remove duplicates
            existingDayAssignments = Array.from(new Set(existingDayAssignments)).sort((a, b) => a - b);

            let consecutiveCount = 0;
            for(let i = 0; i < existingDayAssignments.length; i++) {
                if (i > 0 && existingDayAssignments[i] === existingDayAssignments[i-1] + 1) {
                    consecutiveCount++;
                } else {
                    consecutiveCount = 1;
                }
                if (consecutiveCount > relaxiation ||6) { // Max 3 consecutive, so >3 (i.e., 4 or more) is a conflict
                    return { isHardConflict: true, isSoftConflict: false, conflictingAssignment: null };
                }
            }

            // If there's a class conflict, it's a soft conflict. Otherwise, no conflicts.
            if (isClassConflict) {
                return { isHardConflict: false, isSoftConflict: true, conflictingAssignment: conflictingAssignment };
            }

            return { isHardConflict: false, isSoftConflict: false, conflictingAssignment: null }; // No conflicts found
        }


        /**
         * Highlights possible cells for the selected slot.
         * @param {Object} slot - The selected slot.
         */
        function highlightPossibleCells(slot) {
            clearHighlights(); // Clear any existing highlights

            // Determine which table to highlight based on the active view
            let targetTableElement = null;
            if (currentMainTimetableDisplay.type === 'full') {
                targetTableElement = timetableTable;
            } else if (currentMainTimetableDisplay.type === 'teacher' && currentMainTimetableDisplay.id === slot.teacher_id) {
                targetTableElement = individualTimetableTable;
            } else if (currentMainTimetableDisplay.type === 'class' && (currentMainTimetableDisplay.id === slot.class || slot.class_name)) { // Check both properties
                targetTableElement = individualTimetableTable;
            } else {
                // If the selected slot doesn't match the current view, inform the user
                showMessage(`To place this slot, please switch to the "Timetable Management" tab and view the Full Timetable, or the timetable for ${teachers[slot.teacher_id]?.teacherName || 'this teacher'} or class ${slot.class || slot.class_name}.`, 'info');
                return;
            }

            const allCells = targetTableElement.querySelectorAll('tbody td[data-slot-key]');

            // Highlight the relevant row/column
            if (currentMainTimetableDisplay.type === 'full') {
                const teacherRow = targetTableElement.querySelector(`tbody tr[data-teacher-id="${slot.teacher_id}"]`);
                if (teacherRow) {
                    teacherRow.classList.add('highlight-relevant-row');
                }
            }
            // For teacher/class view, the entire table is already relevant, so no extra row highlighting needed.


            allCells.forEach(cell => {
                const cellTeacherId = cell.dataset.teacherId;
                const cellClassName = cell.dataset.className;
                const slotKey = cell.dataset.slotKey;
                const day = slotKey.slice(0, 2);
                const period_num = parseInt(slotKey.slice(2));

                let isRelevantCell = false;
                if (currentMainTimetableDisplay.type === 'full') {
                    isRelevantCell = (cellTeacherId === slot.teacher_id);
                } else if (currentMainTimetableDisplay.type === 'teacher') {
                    isRelevantCell = (cellTeacherId === currentMainTimetableDisplay.id);
                } else if (currentMainTimetableDisplay.type === 'class') {
                    isRelevantCell = (cellClassName === currentMainTimetableDisplay.id);
                }

                if (isRelevantCell) {
                    // Pass the activeMovingSlot to checkConflicts to exclude it from conflict detection
                    const conflictResult = checkConflicts(slot.teacher_id, day, period_num, slot.class || slot.class_name, currentTimetableData, slot);

                    if (conflictResult.isHardConflict) {
                        cell.classList.add('highlight-conflict');
                    } else if (conflictResult.isSoftConflict) {
                        cell.classList.add('highlight-swappable');
                    } else {
                        cell.classList.add('highlight-possible');
                    }
                } else {
                    // Cells not relevant to the selected slot's teacher/class in the current view are conflicts
                    cell.classList.add('highlight-conflict');
                }
            });
        }

        /**
         * Clears all highlights from timetable cells and rows.
         */
        function clearHighlights() {
            timetableTable.querySelectorAll('.highlight-possible, .highlight-swappable, .highlight-conflict').forEach(cell => {
                cell.classList.remove('highlight-possible', 'highlight-swappable', 'highlight-conflict');
            });
            individualTimetableTable.querySelectorAll('.highlight-possible, .highlight-swappable, .highlight-conflict').forEach(cell => {
                cell.classList.remove('highlight-possible', 'highlight-swappable', 'highlight-conflict');
            });
            // Also remove the teacher row highlight
            timetableTable.querySelectorAll('.highlight-relevant-row').forEach(row => {
                row.classList.remove('highlight-relevant-row');
            });
            individualTimetableTable.querySelectorAll('.highlight-relevant-row').forEach(row => {
                row.classList.remove('highlight-relevant-row');
            });
        }

        /**
         * Updates the position of the moving element.
         * @param {MouseEvent} event - The mousemove event.
         */
        function handleMouseMove(event) {
            if (movingElement) {
                movingElement.style.left = `${event.clientX}px`;
                movingElement.style.top = `${event.clientY}px`;
            }
        }

        /**
         * Handles the mouseup event anywhere on the document to cancel slot movement if not placed.
         * @param {MouseEvent} event - The mouseup event.
         */
        function handleMouseUpOutsideTarget(event) {
            // If there's an active moving slot and the click target is NOT a valid placement cell,
            // or if it's the original source card/cell (meaning user clicked it again to deselect/cancel),
            // or if it's the moving element itself (which should have pointer-events: none, but as a fallback)
            const targetCell = event.target.closest('td[data-slot-key]');
            const isOriginalSource = (originalSourceInfo && originalSourceInfo.element === event.target.closest('.slot-card, td'));

            // If the user clicks on the original source element, it means they want to deselect.
            // If they click outside a valid target, it means cancellation.
            if (activeMovingSlot && (isOriginalSource || !targetCell || (!targetCell.classList.contains('highlight-possible') && !targetCell.classList.contains('highlight-swappable')))) {
                showMessage('Placement cancelled. Slot returned to unassigned slots.', 'info');
                rollbackMovingSlot();
                refreshCurrentTimetableDisplay(); // Re-render to show rollback
            }
        }

        /**
         * Selects a slot for moving (click-to-move).
         * @param {Object|null} slotData - The data of the slot being selected. Null to deselect.
         * @param {Object|null} sourceInfo - Information about where the slot came from.
         * @param {MouseEvent} event - The mouse event.
         */
        function selectSlotForMove(slotData, sourceInfo, event) {
            // If there's already an active moving slot, cancel it first to ensure a clean state
            if (activeMovingSlot) {
                cancelMovingSlot();
            }

            if (slotData) {
                if (slotData.isLocked) {
                    showMessage('This slot is locked and cannot be moved. Please unlock it first.', 'error');
                    return;
                }
                
                // Ensure the 'class' property is always present for the moving slot display
                const classForMovingSlot = slotData.class || slotData.class_name || '';
                activeMovingSlot = { ...slotData, class: classForMovingSlot }; // Make a copy and ensure class property
                originalSourceInfo = { ...sourceInfo }; // Store source info

                // Visually indicate selection
                if (sourceInfo.type === 'unassigned-card') {
                    sourceInfo.element.classList.add('selected');
                    sourceInfo.element.style.opacity = '0.4'; // Dim the original card
                } else if (sourceInfo.type === 'timetable-cell') {
                    // Immediately remove the slot from the timetable data when picked up
                    const originalSlotKey = sourceInfo.slotKey;
                    const originalTeacherId = sourceInfo.teacherId;
                    const originalClass = slotData.class || slotData.class_name;
                    const originalSubject = slotData.subject;

                    // Save state BEFORE modifying currentTimetableData
                    saveStateForUndo();

                    currentTimetableData[originalSlotKey] = (currentTimetableData[originalSlotKey] || []).filter(
                        (assignment) => assignment && !(assignment.teacher_id === originalTeacherId &&
                                          assignment.class === originalClass &&
                                          assignment.subject === originalSubject &&
                                          assignment.slotNumber === slotData.slotNumber)
                    );
                    if (currentTimetableData[originalSlotKey].length === 0) {
                        delete currentTimetableData[originalSlotKey];
                    }
                    // Visually clear the cell's content
                    sourceInfo.element.textContent = '';
                    sourceInfo.element.classList.remove('locked-cell');
                    saveTimetable(); // Save the state after picking up
                    displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value);
           
                }

                // Create the moving visual element
                movingElement = document.createElement('div');
                movingElement.className = 'moving-slot';
                // Use the standardized 'class' property for display
                movingElement.textContent = `${activeMovingSlot.class ? activeMovingSlot.class + ' - ' : ''}${activeMovingSlot.subject}${activeMovingSlot.slotNumber ? '-' + activeMovingSlot.slotNumber : ''} (${teachers[activeMovingSlot.teacher_id]?.teacherName || 'N/A'})`;
                document.body.appendChild(movingElement);

                // Position the moving element
                movingElement.style.left = `${event.clientX}px`;
                movingElement.style.top = `${event.clientY}px`;

                // Add event listener for mousemove to update position
                document.addEventListener('mousemove', handleMouseMove);
                // Add event listener for mouseup anywhere on the document to cancel if not placed
                document.addEventListener('mouseup', handleMouseUpOutsideTarget);

                highlightPossibleCells(activeMovingSlot);
                showMessage(`Selected: ${activeMovingSlot.subject}${activeMovingSlot.slotNumber ? '-' + activeMovingSlot.slotNumber : ''} for ${activeMovingSlot.class || activeMovingSlot.class_name}. Click a green cell to place, or orange to swap.`, 'info');
            }
        }

        /**
         * Attempts to place the actively moving slot into a target cell.
         * @param {HTMLElement} targetElement - The element that was clicked (could be a cell or something else).
         * @param {MouseEvent} event - The mouse event that triggered the placement.
         */
        function attemptPlaceSlot(targetElement, event) {
            if (!activeMovingSlot) return; // No slot selected to place

            // Capture current moving slot and source info before potentially clearing them
            const currentMovingSlot = { ...activeMovingSlot };
            const currentOriginalSourceInfo = { ...originalSourceInfo };
            
            // Clear the currently moving slot state and visual element immediately
            cancelMovingSlot(); // This ensures the old movingElement is removed and activeMovingSlot is reset

            const targetCell = targetElement.closest('td[data-slot-key]');
            if (!targetCell) {
                showMessage('Placement cancelled. Clicked outside a valid timetable cell. Slot returned to unassigned slots.', 'info');
                // Rollback the *captured* currentMovingSlot
                rollbackSpecificSlot(currentMovingSlot, currentOriginalSourceInfo);
                refreshCurrentTimetableDisplay();
                return;
            }

            const slotKey = targetCell.dataset.slotKey;
            const day = slotKey.slice(0, 2);
            const period_num = parseInt(slotKey.slice(2));

            // Perform conflict check with the *incoming* slot (currentMovingSlot)
            const conflictResult = checkConflicts(currentMovingSlot.teacher_id, day, period_num, currentMovingSlot.class || currentMovingSlot.class_name, currentTimetableData, currentMovingSlot);

            if (conflictResult.isHardConflict) {
                showMessage('Cannot place slot here: Placement would violate a hard rule (e.g., teacher unavailable, locked slot, or max daily/consecutive hours).', 'error');
                // Rollback the *captured* currentMovingSlot
                rollbackSpecificSlot(currentMovingSlot, currentOriginalSourceInfo);
                refreshCurrentTimetableDisplay();
                return;
            }

            // Save state BEFORE modifying currentTimetableData or currentUnassignedSlots
            saveStateForUndo();

            // --- Perform Placement/Swap ---
            let newSlotToPickUp = null;

            // The currentMovingSlot has already been logically removed from its original source
            // if it came from a timetable cell in selectSlotForMove.
            // If it came from unassigned, it's removed from currentUnassignedSlots here.
            if (currentOriginalSourceInfo.type === 'unassigned-card') {
                const idx = currentUnassignedSlots.findIndex(s => 
                    s.class_name === currentMovingSlot.class_name && 
                    s.subject === currentMovingSlot.subject && 
                    s.teacher_id === currentMovingSlot.teacher_id && 
                    s.slotNumber === currentMovingSlot.slotNumber
                );
                if (idx !== -1) {
                    currentUnassignedSlots.splice(idx, 1);
                }
            }
            
            // 2. Handle existing conflicting assignment in the target cell (if any)
            if (conflictResult.isSoftConflict && conflictResult.conflictingAssignment) {
                const existingAssignment = conflictResult.conflictingAssignment;
                
                // Remove the existing conflicting assignment from the target cell
                currentTimetableData[slotKey] = (currentTimetableData[slotKey] || []).filter(
                    (assignment) => assignment && !(assignment.teacher_id === existingAssignment.teacher_id &&
                                      assignment.class === existingAssignment.class &&
                                      assignment.subject === existingAssignment.subject &&
                                      assignment.slotNumber === existingAssignment.slotNumber)
                );
                
                // This existing assignment becomes the new slot to pick up
                newSlotToPickUp = existingAssignment;
            }

            // 3. Place the currentMovingSlot into the target cell
            if (!currentTimetableData[slotKey]) {
                currentTimetableData[slotKey] = [];
            }
            currentTimetableData[slotKey].push({
                // Use the 'class' property from activeMovingSlot which is guaranteed to be set
                class: currentMovingSlot.class, 
                teacher_id: currentMovingSlot.teacher_id,
                teacherName: teachers[currentMovingSlot.teacher_id]?.teacherName,
                subject: currentMovingSlot.subject,
                day: day,
                period_num: period_num,
                isLocked: false, // Newly placed/swapped slots are not locked by default
                slotNumber: currentMovingSlot.slotNumber // Ensure slotNumber is carried over
            });

            showMessage('Slot placed successfully! Timetable saved.', 'success');

            // Re-render the current view to reflect the changes
            refreshCurrentTimetableDisplay();

            if (newSlotToPickUp) {
                // Now, select the newly picked-up slot to initiate a new drag
                selectSlotForMove({
                    class_name: newSlotToPickUp.class, // Use class_name for consistency with unassigned slots
                    subject: newSlotToPickUp.subject,
                    teacher_id: newSlotToPickUp.teacher_id,
                    isClassCharge: teachers[newSlotToPickUp.teacher_id]?.classInCharge === newSlotToPickUp.class,
                    isLocked: false, // It's now picked up, so it's not locked
                    slotNumber: newSlotToPickUp.slotNumber,
                    class: newSlotToPickUp.class // Also set 'class' for consistency
                }, {
                    type: 'timetable-cell', // It came from a timetable cell
                    element: targetCell, // The cell it was removed from
                    slotKey: slotKey,
                    teacherId: newSlotToPickUp.teacher_id,
                    class: newSlotToPickUp.class,
                    subject: newSlotToPickUp.subject,
                    slotNumber: newSlotToPickUp.slotNumber
                }, event); // Pass the original event to position the moving element
                showMessage(`Slot placed. Conflicting slot "${newSlotToPickUp.subject}${newSlotToPickUp.slotNumber ? '-' + newSlotToPickUp.slotNumber : ''}" for "${newSlotToPickUp.class}" from "${teachers[newSlotToPickUp.teacher_id]?.teacherName}" picked up.`, 'info');
            } else {
                // No conflict, so just clear the highlights (already done by cancelMovingSlot)
                clearHighlights();
            }
        }

        /**
         * Rolls back the currently moving slot to its original location.
         */
        function rollbackMovingSlot() {
            if (!activeMovingSlot || !originalSourceInfo) return; // Nothing to rollback

            rollbackSpecificSlot(activeMovingSlot, originalSourceInfo);
            cancelMovingSlot(); // Clear the active moving slot and element
        }

        /**
         * Rolls back a specific slot to its original location (used after a failed placement attempt).
         * Instead of returning to its original timetable cell, it's added to the unassigned slots.
         * @param {Object} slotData - The data of the slot to rollback.
         * @param {Object} sourceInfo - Information about where the slot originally came from.
         */
        function rollbackSpecificSlot(slotData, sourceInfo) {
            if (sourceInfo.type === 'unassigned-card') {
                // If it came from an unassigned card, it was never removed from currentUnassignedSlots
                // We only need to restore its visual state if it was selected.
                const originalCard = sourceInfo.element;
                if (originalCard && originalCard.classList.contains('selected')) {
                    originalCard.classList.remove('selected');
                    originalCard.style.opacity = '1';
                }
            } else if (sourceInfo.type === 'timetable-cell') {
                // If it came from a timetable cell, it was removed from currentTimetableData in selectSlotForMove.
                // Now, instead of putting it back in the timetable, add it to unassigned.
                addUniqueUnassignedSlot({ // Use addUniqueUnassignedSlot
                    class_name: slotData.class, // Use class_name for consistency with unassigned slots
                    subject: slotData.subject,
                    teacher_id: slotData.teacher_id,
                    isClassCharge: teachers[slotData.teacher_id]?.classInCharge === slotData.class,
                    isLocked: false, // Always unassign as unlocked
                    slotNumber: slotData.slotNumber,
                    class: slotData.class // Also set 'class' for consistency
                });
            }
        }

        /**
         * Cancels the current slot movement, clearing the active slot and visual element.
         */
        function cancelMovingSlot() {
            if (movingElement) {
                movingElement.remove();
                movingElement = null;
            }
            if (originalSourceInfo && originalSourceInfo.type === 'unassigned-card' && originalSourceInfo.element) {
                 originalSourceInfo.element.classList.remove('selected');
                 originalSourceInfo.element.style.opacity = '1';
            }
            activeMovingSlot = null;
            originalSourceInfo = null;
            clearHighlights();
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUpOutsideTarget);
        }


        /**
         * Refreshes the currently active timetable display.
         * This function is called after any manual assignment/unassignment or lock/unlock.
         */
        function refreshCurrentTimetableDisplay() {
            if (currentMainTimetableDisplay.type === 'full') {
                displayFullTimetable();
            } else if (currentMainTimetableDisplay.type === 'teacher') {
                displayTeacherTimetableEditable(currentMainTimetableDisplay.id);
            } else if (currentMainTimetableDisplay.type === 'class') {
                displayClassTimetableEditable(currentMainTimetableDisplay.id);
            }
            saveTimetable(); // Save changes after refreshing display
        }


        // Custom Confirmation Modal (replaces `confirm()` and `alert()`)
        function showCustomConfirmation(message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h2>Confirmation</h2>
                    <p>${message}</p>
                    <div class="flex justify-end gap-4 mt-4">
                        <button id="confirm-yes" class="action-button bg-green-600 hover:bg-green-700">Yes</button>
                        <button id="confirm-no" class="action-button bg-red-600 hover:bg-red-700">No</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.style.display = 'block';

            document.getElementById('confirm-yes').onclick = () => {
                modal.remove();
                onConfirm();
            };
            document.getElementById('confirm-no').onclick = () => {
                modal.remove();
                onCancel();
            };
        }


        // --- Data Processing Functions ---

        /**
         * Processes the raw data from CSV/Excel into a structured format.
         * @param {Array<Array<any>>} rawData - The array of rows from the parsed file.
         */
        function processImportedData(rawData) {
            if (!rawData || rawData.length === 0) {
                showMessage('No data found in the uploaded file.', 'error');
                return;
            }

            const expectedCoreHeaders = ['Teacher ID', 'Teacher Name', 'Class In Charge', 'Unavailable Periods'];
            const subjectHeaderPattern = /^Subject\d+$/;

            // Find the header row
            let headerRowIndex = rawData.findIndex(row => row.some(cell => String(cell).trim() === 'Teacher ID'));

            if (headerRowIndex === -1) {
                showMessage('Error: "Teacher ID" header not found in the file. Please check your file format.', 'error');
                return;
            }

            const header = rawData[headerRowIndex].map(h => String(h).trim());

            // Check required headers
            const missingHeaders = expectedCoreHeaders.filter(col => !header.includes(col));
            if (missingHeaders.length > 0) {
                showMessage(`Error: Missing essential headers: ${missingHeaders.join(', ')}. Please refer to the template.`, 'error');
                return;
            }

            importedTeachersRawData = [];
            const dataStartRow = headerRowIndex + 1;

            for (let i = dataStartRow; i < rawData.length; i++) {
                const row = rawData[i];
                // Skip empty rows or rows that don't have enough data for a teacher ID and name
                if (!row || String(row[header.indexOf('Teacher ID')]).trim() === '' || String(row[header.indexOf('Teacher Name')]).trim() === '') {
                    continue;
                }

                const teacherData = {
                    teacherId: String(row[header.indexOf('Teacher ID')]).trim(),
                    teacherName: String(row[header.indexOf('Teacher Name')]).trim(),
                    classInCharge: String(row[header.indexOf('Class In Charge')]).trim(),
                    unavailableSlots: String(row[header.indexOf('Unavailable Periods')]).trim()
                        .split(',').map(s => s.trim()).filter(s => s),
                    subjects: []
                };

                // Parse dynamic subject columns (e.g., Subject1, Subject2, etc.)
                for (let j = 0; j < header.length; j++) {
                    const headerName = header[j];
                    if (subjectHeaderPattern.test(headerName)) {
                        const subjectValue = String(row[j] || '').trim();
                        if (subjectValue) {
                            // Expected format: "Class-SubjectName-Hours"
                            const parts = subjectValue.split('-');
                            if (parts.length === 3) {
                                const [className, subjectName, hoursStr] = parts;
                                const hours = parseInt(hoursStr);
                                if (className && subjectName && !isNaN(hours) && hours > 0) {
                                    teacherData.subjects.push({
                                        class: className,
                                        name: subjectName,
                                        hours: hours
                                    });
                                } else {
                                    console.warn(`Invalid subject format or hours for ${subjectValue} in row ${i + 1}. Skipping.`);
                                }
                            } else {
                                console.warn(`Unexpected subject format "${subjectValue}" in row ${i + 1}. Expected "Class-SubjectName-Hours".`);
                            }
                        }
                    }
                }

                if (teacherData.teacherId && teacherData.teacherName && teacherData.subjects.length > 0) {
                    importedTeachersRawData.push(teacherData);
                } else {
                    console.warn("Skipping incomplete or invalid row (missing ID, Name, or Subjects):", row);
                }
            }

            if (importedTeachersRawData.length === 0) {
                showMessage('No valid teacher data found after processing. Please check your file and the required format.', 'error');
                isDataImported = false;
            } else {
                isDataImported = true;
                showMessage('Data imported successfully! Now, click "Create Slots & Generate".', 'success');
            }

            updateButtonStates();
        }

        /**
         * Creates raw subject slots based on teacher data.
         * This is a preparatory step before actual timetable generation.
         * @param {Array<Object>} teachersDataToProcess - The array of teacher data.
         */
        function createSlots(teachersDataToProcess) {
            if (!teachersDataToProcess || teachersDataToProcess.length === 0) {
                showMessage('No teacher data available to create slots. Please import data or use demo data.', 'error');
                areSlotsCreated = false;
                updateButtonStates();
                return;
            }

            // Save state before generating new slots
            saveStateForUndo();

            teachers = {}; // Reset global teachers object
            requiredSlots = []; // Reset global required slots

            teachersDataToProcess.forEach(teacherData => {
                // Initialize teacher object with base properties
                teachers[teacherData.teacherId] = {
                    teacher_id: teacherData.teacherId,
                    teacherName: teacherData.teacherName,
                    classInCharge: teacherData.classInCharge,
                    subjects: teacherData.subjects,
                    unavailable_slots: new Set(teacherData.unavailableSlots),
                };
            });

            // Generate a 'required slot' for each subject hour with a unique slotNumber
            teachersDataToProcess.forEach(teacherData => {
                teacherData.subjects.forEach(subjectData => {
                    const { name: subjectName, hours, class: className } = subjectData;
                    for (let i = 0; i < hours; i++) {
                        requiredSlots.push({
                            class_name: className,
                            subject: subjectName,
                            teacher_id: teacherData.teacherId,
                            isClassCharge: className === teachers[teacherData.teacherId].classInCharge,
                            slotNumber: i + 1 // Assign a unique number for each hour of the subject
                        });
                    }
                });
            });

            // Populate the teacher and class dropdowns
            populateDropdowns();
            populateUnassignedFilterDropdowns();
            
            // Store processed teachers data to local storage for persistence
            saveTeachersToLocalStorage();
            // Save teachers and class data to Firebase
            if (db && userId) { // Only attempt to save to Firestore if Firebase is initialized and user is authenticated
                saveTeachersDataToFirestore();
                saveClassDataToFirestore();
            }

            areSlotsCreated = true;
            currentUnassignedSlots = []; // Initialize empty, then add unique slots
            requiredSlots.forEach(slot => addUniqueUnassignedSlot(slot)); // Add all required slots as unassigned initially

            // NEW: Filter currentUnassignedSlots to ensure they are all in requiredSlots (redundant here, but good as a safeguard)
            currentUnassignedSlots = currentUnassignedSlots.filter(unassignedSlot => {
                return requiredSlots.some(reqSlot =>
                    reqSlot.class_name === unassignedSlot.class_name &&
                    reqSlot.subject === unassignedSlot.subject &&
                    reqSlot.teacher_id === unassignedSlot.teacher_id &&
                    reqSlot.slotNumber === unassignedSlot.slotNumber
                );
            });

            localStorage.setItem(LOCAL_STORAGE_KEY_SLOTS, JSON.stringify(currentUnassignedSlots));

            displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value);
            showMessage('Slots created successfully. Generating timetable...', 'success');
            updateButtonStates();
            // NEW: Automatically generate timetable
            // generateTimetable();
        }
        function createSlotsfromlocal(teachersDataToProcess) {
            if (!teachersDataToProcess || teachersDataToProcess.length === 0) {
                showMessage('No teacher data available to create slots. Please import data or use demo data.', 'error');
                areSlotsCreated = false;
                updateButtonStates();
                return;
            }

            // Save state before generating new slots
            saveStateForUndo();

            teachers = {}; // Reset global teachers object
            requiredSlots = []; // Reset global required slots

            teachersDataToProcess.forEach(teacherData => {
                // Initialize teacher object with base properties
                teachers[teacherData.teacher_id] = {
                    teacher_id: teacherData.teacher_id,
                    teacherName: teacherData.teacherName,
                    classInCharge: teacherData.classInCharge||"",
                    subjects: teacherData.subjects,
                    unavailable_slots: new Set(teacherData.unavailable_slots),
                };
            });

            // Generate a 'required slot' for each subject hour with a unique slotNumber
            teachersDataToProcess.forEach(teacherData => {
                teacherData.subjects.forEach(subjectData => {
                    const { name: subjectName, hours, class: className } = subjectData;
                    for (let i = 0; i < hours; i++) {
                        requiredSlots.push({
                            class_name: className,
                            subject: subjectName,
                            teacher_id: teacherData.teacher_id,
                            isClassCharge: className === teachers[teacherData.teacher_id].classInCharge,
                            slotNumber: i + 1 // Assign a unique number for each hour of the subject
                        });
                    }
                });
            });

            // Populate the teacher and class dropdowns
            populateDropdowns();
            populateUnassignedFilterDropdowns();
            
            // Store processed teachers data to local storage for persistence
            saveTeachersToLocalStorage();
            // Save teachers and class data to Firebase
            if (db && userId) { // Only attempt to save to Firestore if Firebase is initialized and user is authenticated
                saveTeachersDataToFirestore();
                saveClassDataToFirestore();
            }

            areSlotsCreated = true;
            // currentUnassignedSlots = []; // Initialize empty, then add unique slots
            // requiredSlots.forEach(slot => addUniqueUnassignedSlot(slot)); // Add all required slots as unassigned initially
            //  // NEW: Filter currentUnassignedSlots to ensure they are all in requiredSlots (redundant here, but good as a safeguard)
            currentUnassignedSlots = currentUnassignedSlots.filter(unassignedSlot => {
                return requiredSlots.some(reqSlot =>
                    reqSlot.class_name === unassignedSlot.class_name &&
                    reqSlot.subject === unassignedSlot.subject &&
                    reqSlot.teacher_id === unassignedSlot.teacher_id &&
                    reqSlot.slotNumber === unassignedSlot.slotNumber
                );
            });

//             localStorage.setItem(LOCAL_STORAGE_KEY_SLOTS, JSON.stringify(currentUnassignedSlots));
// // NEW: Save currentUnassignedSlots to Firestore
            // localStorage.setItem(LOCAL_STORAGE_KEY_SLOTS, JSON.stringify(currentUnassignedSlots));

            displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value);
            showMessage('Slots created successfully. Generating timetable...', 'success');
            updateButtonStates();
            // NEW: Automatically generate timetable
           // generateTimetable();
        }

        /**
         * Populates the teacher and class dropdowns based on the 'teachers' and 'requiredSlots' data.
         */
        function populateDropdowns() {
            // Editable dropdowns for Management tab
            teacherDropdownEditable.innerHTML = '<option value="">Select Teacher</option>';
            classDropdownEditable.innerHTML = '<option value="">Select Class</option>';
            if(!teachers){return null}
            const sortedTeachers = Object.values(teachers).sort((a,b) => a.teacherName.localeCompare(b.teacherName));
            sortedTeachers.forEach(teacher => {
                const optionEditable = document.createElement('option');
                optionEditable.value = teacher.teacher_id;
                optionEditable.textContent = `${teacher.teacherName} (${teacher.teacher_id})`;
                teacherDropdownEditable.appendChild(optionEditable);
            });

            const uniqueClasses = new Set();
            for (const slot of requiredSlots) {
                uniqueClasses.add(slot.class_name);
            }
            const sortedClasses = Array.from(uniqueClasses).sort();
            sortedClasses.forEach(className => {
                const optionEditable = document.createElement('option');
                optionEditable.value = className;
                optionEditable.textContent = className;
                classDropdownEditable.appendChild(optionEditable);
            });
        }

        /**
         * Populates the unassigned slot filter dropdowns.
         */
        function populateUnassignedFilterDropdowns() {
            filterUnassignedClassDropdown.innerHTML = '<option value="">All Classes</option>';
            const uniqueClasses = new Set();
            requiredSlots.forEach(slot => uniqueClasses.add(slot.class_name));
            Array.from(uniqueClasses).sort().forEach(className => {
                const option = document.createElement('option');
                option.value = className;
                option.textContent = className;
                filterUnassignedClassDropdown.appendChild(option);
            });

            filterUnassignedTeacherDropdown.innerHTML = '<option value="">All Teachers</option>';
            const uniqueTeachers = new Set();
            requiredSlots.forEach(slot => uniqueTeachers.add(slot.teacher_id));
            Array.from(uniqueTeachers).sort((a,b) => teachers[a]?.teacherName.localeCompare(teachers[b]?.teacherName)).forEach(teacherId => {
                const option = document.createElement('option');
                option.value = teacherId;
                option.textContent = `${teachers[teacherId]?.teacherName} (${teacherId})`;
                filterUnassignedTeacherDropdown.appendChild(option);
            });
        }


        /**
         * Core timetable generation logic.
         * This is a simplified client-side greedy algorithm. For production, consider a backend solver.
         */
        function generateTimetable() {
            if (!areSlotsCreated || requiredSlots.length === 0) {
                showMessage('Please create slots first before generating the timetable.', 'error');
                return;
            }

            showLoading('Generating timetable...');

            // Save state before generating new timetable
            saveStateForUndo();

            const tempAssignedTimetable = {}; // This will be built up
            const lockedRequiredSlots = []; // These are the 'requiredSlot' objects that are satisfied by locked assignments

            // Populate tempAssignedTimetable with locked slots and identify which required slots they fulfill
            for (const slotKey in currentTimetableData) {
                const assignmentsInPeriod = currentTimetableData[slotKey] || [];
                assignmentsInPeriod.forEach(assignment => {
                    if (assignment && assignment.isLocked) { // Added 'assignment &&'
                        if (!tempAssignedTimetable[slotKey]) {
                            tempAssignedTimetable[slotKey] = [];
                        }
                        tempAssignedTimetable[slotKey].push(assignment);
                        // Mark this specific required slot as 'taken' by a locked assignment
                        lockedRequiredSlots.push({
                            class_name: assignment.class,
                            subject: assignment.subject,
                            teacher_id: assignment.teacher_id,
                            slotNumber: assignment.slotNumber
                        });
                    }
                });
            }

            // Determine which required slots still need to be placed
            let slotsToPlace = [];
            const lockedRequiredSlotsTracker = new Map(); // Map: "class-subject-teacher-slotNumber" -> count
            lockedRequiredSlots.forEach(s => {
                const key = `${s.class_name}-${s.subject}-${s.teacher_id}-${s.slotNumber}`;
                lockedRequiredSlotsTracker.set(key, (lockedRequiredSlotsTracker.get(key) || 0) + 1);
            });

            requiredSlots.forEach(reqSlot => {
                const key = `${reqSlot.class_name}-${reqSlot.subject}-${reqSlot.teacher_id}-${reqSlot.slotNumber}`;
                if (lockedRequiredSlotsTracker.has(key) && lockedRequiredSlotsTracker.get(key) > 0) {
                    lockedRequiredSlotsTracker.set(key, lockedRequiredSlotsTracker.get(key) - 1);
                } else {
                    slotsToPlace.push(reqSlot); // This slot still needs to be placed
                }
            });

            // Helper: Assign slot if no conflict (modified to use tempAssignedTimetable and check for existing locked slots)
            function tryAssignSlot(requiredSlot, day, period_num, slotKey, currentWorkingTimetable) {
                const teacher = teachers[requiredSlot.teacher_id];
                if (!teacher) {
                    console.warn(`Teacher ${requiredSlot.teacher_id} not found for slot. Skipping.`);
                    return false;
                }

                // Check for conflicts (using the currentWorkingTimetable state and excluding the slot being moved)
                const conflictResult = checkConflicts(teacher.teacher_id, day, period_num, requiredSlot.class_name, currentWorkingTimetable, requiredSlot);
                
                // If there's a hard conflict, or if it's already occupied (even by a soft conflict, we don't overwrite during auto-gen)
                if (conflictResult.isHardConflict || conflictResult.isSoftConflict) {
                    return false; // Cannot assign to a conflicted or occupied cell during auto-generation
                }

                // If no conflicts and cell is empty, assign the slot
                if (!currentWorkingTimetable[slotKey]) currentWorkingTimetable[slotKey] = [];
                currentWorkingTimetable[slotKey].push({
                    class: requiredSlot.class_name,
                    teacher_id: teacher.teacher_id,
                    teacherName: teacher.teacherName,
                    subject: requiredSlot.subject,
                    day, period_num,
                    isLocked: false, // Newly assigned slots are not locked by default
                    slotNumber: requiredSlot.slotNumber // Ensure slotNumber is carried over
                });
                return true;
            }

            // Create a shuffled list of all possible time slots to ensure randomness in assignment attempts
            const allPossibleTimeSlots = [];
            for (const day of DAYS) {
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) { // Corrected loop condition
                    allPossibleTimeSlots.push({ day, period_num: period, slotKey: `${day}${period}` });
                }
            }
            allPossibleTimeSlots.sort(() => Math.random() - 0.5); // Shuffle time slots

            // Step 1: Assign class teacher to first period of each day (from `slotsToPlace`)
            // This logic needs to be careful not to overwrite locked slots.
            // The `tryAssignSlot` function now handles this by checking `isCellLocked`.
            for (const day of DAYS) {
                const period_num = 1;
                const slotKey = `${day}${period_num}`;
                for (let i = 0; i < slotsToPlace.length; i++) {
                    const slot = slotsToPlace[i];
                    const teacher = teachers[slot.teacher_id];
                    if (teacher && teacher.classInCharge === slot.class_name) {
                        if (tryAssignSlot(slot, day, period_num, slotKey, tempAssignedTimetable)) {
                            slotsToPlace.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            // Step 2: Assign "AI" subject slots (from `slotsToPlace`)
            const slotsToProcessForAI = [...slotsToPlace];
            for (let i = 0; i < slotsToProcessForAI.length; i++) {
                const slot = slotsToProcessForAI[i];
                if (slot.subject.toUpperCase() === 'AI') {
                    let assigned = false;
                    for (const timeSlot of allPossibleTimeSlots) {
                        if (tryAssignSlot(slot, timeSlot.day, timeSlot.period_num, timeSlot.slotKey, tempAssignedTimetable)) {
                            slotsToPlace = slotsToPlace.filter(s => s !== slot);
                            assigned = true;
                            break;
                        }
                    }
                }
            }

            // Step 3: Assign remaining slots randomly (from `slotsToPlace`)
            slotsToPlace.sort(() => Math.random() - 0.5);
            const remainingSlotsToProcess = [...slotsToPlace];
            for (let i = 0; i < remainingSlotsToProcess.length; i++) {
                const slot = remainingSlotsToProcess[i];
                let assigned = false;
                for (const timeSlot of allPossibleTimeSlots) {
                    if (tryAssignSlot(slot, timeSlot.day, timeSlot.period_num, timeSlot.slotKey, tempAssignedTimetable)) {
                        slotsToPlace = slotsToPlace.filter(s => s !== slot);
                        assigned = true;
                        break;
                    }
                }
            }

            // Finalize
            currentTimetableData = tempAssignedTimetable;
            currentUnassignedSlots = slotsToPlace; // Remaining unassigned slots

            hideLoading();
            if (currentUnassignedSlots.length > 0) {
                showMessage(`Timetable generated, but ${currentUnassignedSlots.length} slots remain unassigned.`, 'error');
            } else {
                showMessage('Timetable generated successfully! All slots assigned.', 'success');
            }

            displayFullTimetable();
        }

        // --- Local Storage Functions ---
        /**
         * Saves the current timetable, unassigned slots, teachers data, and substitutions to local storage.
         */
        function saveTimetable() {
            try {
                // Convert Sets to Arrays for localStorage compatibility
                const teachersToSave = {};
                for (const id in teachers) {
                    teachersToSave[id] = {
                        ...teachers[id],
                        unavailable_slots: Array.from(teachers[id].unavailable_slots),
                    };
                }

                localStorage.setItem(LOCAL_STORAGE_KEY_TIMETABLE, JSON.stringify(currentTimetableData));
                localStorage.setItem(LOCAL_STORAGE_KEY_UNASSIGNED, JSON.stringify(currentUnassignedSlots));
                localStorage.setItem(LOCAL_STORAGE_KEY_TEACHERS, JSON.stringify(teachersToSave)); // Save processed teachers data
                localStorage.setItem(LOCAL_STORAGE_KEY_SLOTS, JSON.stringify(requiredSlots)); // Save required slots
                var time =  Date.now(); // Get current timestamp
                console.log('Timetable, unassigned slots, teachers, and required slots saved to local storage.',time);
                localStorage.setItem("timetableupdated", time);

            } catch (e) {
                console.error('Error saving to local storage:', e);
                showMessage('Failed to save timetable to local storage. Browser storage might be full.', 'error');
            }
            updateButtonStates(); // Update button states after saving
        }

        /**
         * Saves only the processed teachers data to local storage.
         */
        function saveTeachersToLocalStorage() {
            try {
                const teachersToSave = {};
                for (const id in teachers) {
                    teachersToSave[id] = {
                        ...teachers[id],
                        unavailable_slots: Array.from(teachers[id].unavailable_slots),
                    };
                }
                localStorage.setItem(LOCAL_STORAGE_KEY_TEACHERS, JSON.stringify(teachersToSave));
            } catch (e) {
                console.error('Error saving teachers data to local storage:', e);
            }
        }

        // --- Firebase Functions ---

        /**
         * Saves the teachers data to Firestore.
         */
        async function saveTeachersDataToFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                console.warn('Firestore db not initialized or user not authenticated. Skipping teacher data save.');
                return;
            }

            try {
                const teachersToSave = {};
                for (const id in teachers) {
                    teachersToSave[id] = {
                        ...teachers[id],
                        unavailable_slots: Array.from(teachers[id].unavailable_slots),
                    };
                }

                if (Object.keys(teachersToSave).length > 0) {
                    const batch = writeBatch(db);
                    const basePath = getFirestoreBasePath();

                    for (const teacherId in teachersToSave) {
                        const teacherDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_TEACHERS_DATA}`, teacherId);
                        batch.set(teacherDocRef, teachersToSave[teacherId]);
                    }

                    await batch.commit();
                    console.log('All teacher data saved to Firestore.');
                    showMessage('Teacher data saved to cloud!', 'success');
                } else {
                    console.warn("No teacher data to save to Firestore.");
                    showMessage('No teacher data to save to cloud.', 'info');
                }
            } catch (error) {
                showMessage('Error saving teacher data to cloud.', 'error');
                console.error('Error saving teachers data to Firestore:', error);
            }
        }

        /**
         * Saves the class data (requiredSlots) to Firestore.
         */
        async function saveClassDataToFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                console.warn('Firestore db not initialized or user not authenticated. Skipping class data save.');
                return;
            }

            if (requiredSlots.length === 0) {
                console.warn("No class data (requiredSlots) to save to Firestore.");
                return;
            }

            try {
                const basePath = getFirestoreBasePath();
                const classDataDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_CLASS_DATA}`, 'allClasses');
                // Firestore has a 1MB document size limit. If requiredSlots gets very large, this might fail.
                // For now, we'll store it as a single array.
                await setDoc(classDataDocRef, { classes: JSON.stringify(requiredSlots) }); // Stringify to handle complex objects/arrays
                showMessage('Class data saved to cloud!', 'success');
                console.log('Class data saved to Firestore.');
            } catch (error) {
                showMessage('Error saving class data to cloud.', 'error');
                console.error('Error saving class data to Firestore:', error);
            }
        }

        /**
         * Exports the current timetable and unassigned slots to Firestore.
         */
        async function saveTimetableToFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                showMessage('Cannot export to cloud. Firebase not initialized or user not authenticated.', 'error');
                return;
            }

            if (Object.keys(currentTimetableData).length === 0) {
                showMessage('No timetable to export. Please generate one first.', 'error');
                return;
            }

            showLoading('Exporting timetable to cloud...');
            try {
                const batch = writeBatch(db);
                const basePath = getFirestoreBasePath();

                // Save main timetable data (currentTimetableData)
                const timetableDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_TIMETABLES}`, 'mainTimetable');
                // Firestore doesn't allow direct storage of keys with '.', so we serialize
                const serializedTimetableData = {};
                for (const key in currentTimetableData) {
                    serializedTimetableData[key.replace(/\./g, '_')] = currentTimetableData[key];
                }
                batch.set(timetableDocRef, serializedTimetableData);

                // Save unassigned slots
                const unassignedSlotsDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`, 'allUnassignedSlots');
                batch.set(unassignedSlotsDocRef, { unassignedSlots: JSON.stringify(currentUnassignedSlots) });
                // Save updatedTime slots
                
                await batch.commit();
                const updatedTimeDoc = doc(db, `${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`, 'updatedtime');

                setDoc(updatedTimeDoc, { timestamp: Date.now() });

                showMessage('Timetable exported to cloud successfully!', 'success');
                console.log('Timetable exported to Firestore.');
            } catch (error) {
                showMessage('Error exporting timetable to cloud.', 'error');
                console.error('Error exporting timetable to Firestore:', error);
            } finally {
                hideLoading();
            }
        }

        /**
         * Loads teachers data from Firestore.
         * @returns {boolean} True if data was loaded, false otherwise.
         */
        async function loadTeachersDataFromFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                console.warn('Firestore db not initialized or user not authenticated. Skipping teacher data load.');
                return false;
            }

            try {
                const basePath = getFirestoreBasePath();
                const querySnapshot = await getDocs(collection(db, `${basePath}/${FIRESTORE_COLLECTION_TEACHERS_DATA}`));

                const loadedTeachers = {};
                querySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    loadedTeachers[docSnap.id] = {
                        ...data,
                        unavailable_slots: new Set(data.unavailable_slots || []),
                    };

                });
                
                if (Object.keys(loadedTeachers).length === 0) {
                    console.log('No teacher data found in Firestore for this user.');
                    return false;
                }

                teachers = loadedTeachers;
                let teachersArray = Object.values(loadedTeachers);

                // var loadedteachers = loadedTeachers.forEach(data=>{
                //     console.log(teachersArray);
                //     });
                
                

                 console.log(teachersArray);
                createSlotsfromlocal(teachersArray);
                saveTeachersToLocalStorage();
                console.log('Teacher data loaded from Firestore.');
                return true;

            } catch (error) {
                console.error('Error loading teacher data from Firestore:', error.message || error);
                return false;
            }
        }

        /**
         * Loads class data (requiredSlots) from Firestore.
         * @returns {boolean} True if data was loaded, false otherwise.
         */
        async function loadClassDataFromFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                console.warn('Firestore db not initialized or user not authenticated. Skipping class data load.');
                return false;
            }

            try {
                const basePath = getFirestoreBasePath();
                const classDataDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_CLASS_DATA}`, 'allClasses');
                const docSnap = await getDoc(classDataDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    requiredSlots = JSON.parse(data.classes); // Parse back from string
                    console.log('Class data loaded from Firestore.');
                    return true;
                } else {
                    console.log('No class data found in Firestore for this user.');
                    return false;
                }
            } catch (error) {
                console.error('Error loading class data from Firestore:', error);
                return false;
            }
        }

        /**
         * Loads timetable and unassigned slots from Firestore.
         * @returns {boolean} True if data was loaded, false otherwise.
         */
        async function loadTimetableFromFirestore() {
            await firebaseReadyPromise; // Ensure Firebase is ready
            if (!db || !userId) {
                console.warn('Firestore db not initialized or user not authenticated. Skipping timetable data load.');
                return false;
            }

            try {
                const basePath = getFirestoreBasePath();
                
                // Load main timetable data
                const timetableDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_TIMETABLES}`, 'mainTimetable');
                const timetableTimeDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`, 'updatedtime');

                const timetableDocSnap = await getDoc(timetableDocRef);
                const timetabletimeDocSnap = await getDoc(timetableTimeDocRef);

                if (!timetableDocSnap.exists()) {
                    console.log('No main timetable found in Firestore for this user.');
                    return false;
                }
                if (!timetabletimeDocSnap.exists()) {
                    console.log('No main timetableupdated time found in Firestore for this user.');
                    //return false;
                }

                var fireBaseTime = timetabletimeDocSnap.data();
                var localTime = localStorage.getItem("timetableupdated");

                var fireBaseTime = fireBaseTime.timestamp;
                //var localTime = new Date(localTime);
                console.log(fireBaseTime,"local",localTime);
                
                if (fireBaseTime > localTime) {
                    const loadedTimetable = {};
                const data = timetableDocSnap.data();
                for (const key in data) {
                    loadedTimetable[key.replace(/_/g, '.')] = data[key]; // Deserialize keys
                }
                currentTimetableData = loadedTimetable;

                  for (const slotKey in currentTimetableData) {
                        currentTimetableData[slotKey].forEach(assignment => {
                            addUniqueUnassignedSlot({ // Use addUniqueUnassignedSlot
                                class_name: assignment.class,
                                subject: assignment.subject,
                                teacher_id: assignment.teacher_id,
                                isClassCharge: teachers[assignment.teacher_id]?.classInCharge === assignment.class,
                                isLocked: false, // Unlocked when unassigned
                                slotNumber: assignment.slotNumber // Ensure slotNumber is carried over
                            });
                        });
                    }

                // Load unassigned slots
                const unassignedSlotsDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`, 'allUnassignedSlots');
                const unassignedSnap = await getDoc(unassignedSlotsDocRef);
                if (unassignedSnap.exists()) {
                    // Ensure uniqueness when loading from Firestore as well
                    const loadedUnassigned = JSON.parse(unassignedSnap.data().unassignedSlots);
                   // currentUnassignedSlots = []; // Reset
                    loadedUnassigned.forEach(slot => addUniqueUnassignedSlot(slot));
                currentUnassignedSlots = currentUnassignedSlots.filter(unassignedSlot => {
                return requiredSlots.some(reqSlot =>
                    reqSlot.class_name === unassignedSlot.class_name &&
                    reqSlot.subject === unassignedSlot.subject &&
                    reqSlot.teacher_id === unassignedSlot.teacher_id &&
                    reqSlot.slotNumber === unassignedSlot.slotNumber
                );
            });

                } else {
                    currentUnassignedSlots = [];
                }

                console.log('Timetable and unassigned slots loaded from Firestore.');
                return true;
                    console.log('Loaded main timetable from local.');
                    } else {
                        console.log('No need to update the timetable.');
                        
    //             if (localTime == null) {
    //                 //localStorage.setItem("timetableupdated", fireBaseTime.updatedtime);
    //                 console.log('Timetable updated time loaded from Firestore.');
    //                 }
    //                 else if (localTime > fireBaseTime.timestamp) {
    // console.log('Local timetable updated time is newer than Firestore updated time. Asking for confirmation to update Firestore.');

    // const confirmUpdate = confirm("Your local timetable is newer. Do you want to update the online timetable?");

    // if (confirmUpdate) {
    //     console.log('User confirmed. Updating Firestore with local time.');
    //     // fireBaseTime.timestamp = localTime;
    //     saveTimetableToFirestore();
    // } else {
    //     console.log('User declined. Not updating Firestore.');
    // }
//}


                const loadedTimetable = {};
                const data = timetableDocSnap.data();
                for (const key in data) {
                    loadedTimetable[key.replace(/_/g, '.')] = data[key]; // Deserialize keys
                }
                currentTimetableData = loadedTimetable;

                // Load unassigned slots
                const unassignedSlotsDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`, 'allUnassignedSlots');
                const unassignedSnap = await getDoc(unassignedSlotsDocRef);
                if (unassignedSnap.exists()) {
                    // Ensure uniqueness when loading from Firestore as well
                    const loadedUnassigned = JSON.parse(unassignedSnap.data().unassignedSlots);
                    //currentUnassignedSlots = []; // Reset
                    loadedUnassigned.forEach(slot => addUniqueUnassignedSlot(slot));
                    // Ensure all requiredSlots exist in either timetable or currentUnassignedSlots
                    requiredSlots.forEach(reqSlot => {
                        const isInTimetable = Object.values(currentTimetableData).some(slotList =>
                            slotList.some(slot =>
                                slot.class === reqSlot.class_name &&
                                slot.subject === reqSlot.subject &&
                                slot.teacher_id === reqSlot.teacher_id &&
                                slot.slotNumber === reqSlot.slotNumber
                            )
                        );

                        const isInUnassigned = currentUnassignedSlots.some(slot =>
                            slot.class_name === reqSlot.class_name &&
                            slot.subject === reqSlot.subject &&
                            slot.teacher_id === reqSlot.teacher_id &&
                            slot.slotNumber === reqSlot.slotNumber
                        );

                        if (!isInTimetable && !isInUnassigned) {
                            addUniqueUnassignedSlot(reqSlot);
                        }
                    });

                        // NEW: Filter currentUnassignedSlots to ensure they are all in requiredSlots (redundant here, but good as a safeguard)
                    currentUnassignedSlots = currentUnassignedSlots.filter(unassignedSlot => {
                        return requiredSlots.some(reqSlot =>
                            reqSlot.class_name === unassignedSlot.class_name &&
                            reqSlot.subject === unassignedSlot.subject &&
                            reqSlot.teacher_id === unassignedSlot.teacher_id &&
                            reqSlot.slotNumber === unassignedSlot.slotNumber
                        );
                    });

            localStorage.setItem(LOCAL_STORAGE_KEY_SLOTS, JSON.stringify(currentUnassignedSlots));

                } else {
                    currentUnassignedSlots = [];
                }

                console.log('Timetable and unassigned slots loaded from Firestore.');
                return true;
            } 
            } catch (error) {
                console.error('Error loading timetable from Firestore:', error);
                return false;
            }
        }

        /**
         * Attempts to fill any remaining empty slots in the timetable with unassigned periods.
         * This function now respects filters applied to unassigned slots.
         */
        function fillEmptySlots() {
            if (!areSlotsCreated || (requiredSlots.length === 0 && currentUnassignedSlots.length === 0)) {
                showMessage('No slots available to fill. Please create slots first.', 'error');
                return;
            }
            
            showLoading('Attempting to fill empty slots...');

            // Save state before filling slots
            saveStateForUndo();

            let newAssignedCount = 0;

            const allPossibleTimeSlots = [];
            for (const day of DAYS) {
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                    allPossibleTimeSlots.push({ day, period_num: period, slotKey: `${day}${period}` });
                }
            }

            let slotsToProcess = [...currentUnassignedSlots]; // Create a copy to iterate
            const newlyUnassignedSlots = []; // To store slots that couldn't be placed

            // Apply filters to the slotsToProcess if any are active
            const filterClass = filterUnassignedClassDropdown.value;
            const filterTeacher = filterUnassignedTeacherDropdown.value;

            if (filterClass) {
                slotsToProcess = slotsToProcess.filter(s => s.class_name === filterClass);
            }
            if (filterTeacher) {
                slotsToProcess = slotsToProcess.filter(s => s.teacher_id === filterTeacher);
            }

            // Shuffle slots to process for better distribution attempts
            slotsToProcess.sort(() => Math.random() - 0.5);

            // Sort all possible time slots to prioritize early periods and certain days (optional, can experiment)
            allPossibleTimeSlots.sort((a, b) => {
                const dayIndexA = DAYS.indexOf(a.day);
                const dayIndexB = DAYS.indexOf(b.day);
                if (dayIndexA !== dayIndexB) return dayIndexA - dayIndexB;
                return a.period_num - b.period_num;
            });

            for (const requiredSlot of slotsToProcess) { // Iterate through the copy
                const teacher = teachers[requiredSlot.teacher_id];
                if (!teacher) {
                    console.warn(`Teacher ${requiredSlot.teacher_id} not found for unassigned slot. Skipping.`);
                    addUniqueUnassignedSlot(requiredSlot); // Add it back if teacher not found
                    continue;
                }

                let placed = false;
                for (const possibleTimeSlot of allPossibleTimeSlots) {
                    const { day, period_num, slotKey } = possibleTimeSlot;

                    const conflictResult = checkConflicts(teacher.teacher_id, day, period_num, requiredSlot.class_name, currentTimetableData, requiredSlot);

                    if (!conflictResult.isHardConflict && !conflictResult.isSoftConflict) {
                        if (!currentTimetableData[slotKey]) {
                            currentTimetableData[slotKey] = [];
                        }
                        currentTimetableData[slotKey].push({
                            class: requiredSlot.class_name,
                            teacher_id: teacher.teacher_id,
                            teacherName: teacher.teacherName,
                            subject: requiredSlot.subject,
                            day: day,
                            period_num: period_num,
                            isLocked: false,
                            slotNumber: requiredSlot.slotNumber
                        });
                        newAssignedCount++;
                        placed = true;
                        break; // Slot placed, move to the next unassigned slot
                    }
                }

                if (!placed) {
                    newlyUnassignedSlots.push(requiredSlot); // This slot couldn't be placed
                }
            }

            currentUnassignedSlots = newlyUnassignedSlots; // Update the global unassigned list

            hideLoading();
            if (newAssignedCount > 0) {
                showMessage(`${newAssignedCount} slot(s) filled successfully into empty periods. ${currentUnassignedSlots.length} slots remain unassigned.`, 'success');
            } else {
                showMessage('No additional empty slots could be filled with unassigned periods. Either no empty slots available or conflicts prevent placement.', 'error');
            }
            displayManagementTimetable();
        }
    
        /**
         * Displays the full timetable in the management tab.
         */
        function displayManagementTimetable() {
            displayFullTimetable();
            clearHighlights();
            cancelMovingSlot();
        }


        // --- Print Functions ---

        /**
         * Prints the content of a specific table, with a given title.
         * @param {HTMLElement} tableElement - The table DOM element to print.
         * @param {string} title - Title for the printout.
         * @param {string} extraContentHtml - Optional HTML to include before the table (e.g., teacher summary).
         */
        function printTable(tableElement, title, extraContentHtml = '') {
    const printWindow = window.open('', '_blank');
    printWindow.document.write(`
        <html>
        <head>
            <title>${title}</title>
            <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
            <style>
                @media print {
                    @page {
                        size: A4 portrait;
                        margin: 5mm;
                    }
                    body {
                        margin: 0;
                    }
                }

                body {
                    font-family: 'Inter', sans-serif;
                    margin: 10px;
                    background: #fff;
                    color: #000;
                }

                h1 {
                    text-align: center;
                    margin-bottom: 20px;
                    font-size: 1.0rem;
                }

                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: 10px;
                }

                table th, table td {
                    border: 1px solid #000;
                    padding: 8px;
                    text-align: center;
                    font-size: 0.8rem;
                }

                table th {
                    background-color: #f0f0f0;
                }

                table tr:nth-child(even) td {
                    background-color: #fafafa;
                }

                .teacher-print-summary {
                    margin-bottom: 15px;
                    font-size: 0.85rem;
                    text-align: left;
                    border: 1px solid #ddd;
                    padding: 10px;
                    border-radius: 5px;
                    background-color: #f9f9f9;
                }

                .teacher-print-summary h3 {
                    font-size: 1rem;
                    margin-top: 0;
                    margin-bottom: 5px;
                    color: #333;
                }

                .teacher-print-summary p {
                    margin: 0;
                    line-height: 1.4;
                }
            </style>
        </head>
        <body>
            <h1>${title}</h1>
            ${extraContentHtml}
            ${tableElement.outerHTML}
        </body>
        </html>
    `);
    printWindow.document.close();
    printWindow.focus();
    printWindow.print();
}


        /**
         * Generates a separate timetable table HTML for a given teacher, including a summary.
         * @param {string} teacherId - The ID of the teacher.
         * @param {Object} assignedData - The full assigned timetable data.
         * @returns {string} HTML string of the teacher's timetable.
         */
        function getTeacherTimetableHtml(teacherId, assignedData) {
            const teacher = teachers[teacherId];
            if (!teacher) return '';

            // Format subjects as a comma-separated paragraph
            const subjectsList = teacher.subjects.map(sub => `${sub.class}-${sub.name} (${sub.hours}h)`).join(', ');

            let summaryHtml = `<div class="teacher-print-summary">
                <h3>Teacher Summary: ${teacher.teacherName} (${teacher.teacher_id})</h3>
                <p>Class In Charge: ${teacher.classInCharge || 'N/A'}</p>
                <p>Subjects Taught: ${subjectsList || 'N/A'}</p>
                </div>`;


            let tableHtml = `<h2 style="text-align: center; margin-top: 20px;">Timetable for ${teacher.teacherName} (${teacher.teacher_id})</h2>`;
            tableHtml += `<table class="timetable-table"><thead><tr><th>Day</th>`;
            for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                tableHtml += `<th>P${period}</th>`;
            }
            tableHtml += `</tr></thead><tbody>`;

            DAYS.forEach((day, index) => {
                tableHtml += `<tr><td>${FULL_DAYS[index]}</td>`;
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                    const slotKey = `${day}${period}`;
                    const assignmentsInThisPeriod = assignedData[slotKey] || [];
                    const assignmentForThisTeacher = assignmentsInThisPeriod.find(a => a && a.teacher_id === teacherId);
                    const isTeacherUnavailable = teacher.unavailable_slots.has(slotKey);
                    
                    let cellContent = '';
                    if (assignmentForThisTeacher) {
                        const classDisplay = assignmentForThisTeacher.class ? `${assignmentForThisTeacher.class} - ` : '';
                        cellContent = `${classDisplay}${assignmentForThisTeacher.subject}${assignmentForThisTeacher.slotNumber ? '-' + assignmentForThisTeacher.slotNumber : ''}`;
                    } else if (isTeacherUnavailable) {
                        cellContent = 'Unavailable';
                    }
                    
                    tableHtml += `<td>${cellContent}</td>`;
                }
                tableHtml += `</tr>`;
            });
           tableHtml += `</tbody></table>`;
           // return summaryHtml ;//+ tableHtml;
            return tableHtml
        }

        /**
         * Generates a separate timetable table HTML for a given class.
         * @param {string} className - The name of the class.
         * @param {Object} assignedData - The full assigned timetable data.
         * @returns {string} HTML string of the class's timetable.
         */
        function getClassTimetableHtml(className, assignedData) {
            let tableHtml = `<h2 style="text-align: center; margin-top: 20px;">Timetable for Class ${className}</h2>`;
            tableHtml += `<table class="timetable-table"><thead><tr><th>Day</th>`;
            for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                tableHtml += `<th>P${period}</th>`;
            }
            tableHtml += `</tr></thead><tbody>`;

            DAYS.forEach((day, index) => {
                const row = `<tr><td>${FULL_DAYS[index]}</td>`;
                tableHtml += row;
                for (let period = 1; period <= NUM_PERIODS_PER_DAY; period++) {
                    const slotKey = `${day}${period}`;
                    const assignmentsInThisPeriod = assignedData[slotKey] || [];
                    const assignmentForThisClass = assignmentsInThisPeriod.find(a => a && a.class === className);
                    
                    let cellContent = '';
                    if (assignmentForThisClass) {
                        cellContent = `${assignmentForThisClass.subject}${assignmentForThisClass.slotNumber ? '-' + assignmentForThisClass.slotNumber : ''} (Teacher: ${assignmentForThisClass.teacherName})`;
                    }
                    tableHtml += `<td>${cellContent}</td>`;
                }
                tableHtml += `</tr>`;
            });
            tableHtml += `</tbody></table>`;
            return tableHtml;
        }

        // --- Report Generation Functions ---
        function generateReports() {
            teacherReportTableBody.innerHTML = '';
            teacherReportTableFoot.innerHTML = ''; // Clear footer
            classReportTableBody.innerHTML = '';
            classReportTableFoot.innerHTML = ''; // Clear footer

            if (!areSlotsCreated) {
                const noDataRow = teacherReportTableBody.insertRow();
                const cell1 = noDataRow.insertCell();
                cell1.colSpan = 5; // Updated colspan
                cell1.textContent = 'No data available to generate reports. Please create slots first.';
                const noClassDataRow = classReportTableBody.insertRow();
                const cell2 = noClassDataRow.insertCell();
                cell2.colSpan = 5; // Updated colspan
                cell2.textContent = 'No data available to generate reports. Please create slots first.';
                return;
            }

            // --- Teacher Report ---
            const teacherAssignedCounts = {};
            // Calculate assigned periods for each teacher
            for (const slotKey in currentTimetableData) {
                const assignments = currentTimetableData[slotKey];
                assignments.forEach(assignment => {
                    if (assignment) {
                        teacherAssignedCounts[assignment.teacher_id] = (teacherAssignedCounts[assignment.teacher_id] || 0) + 1;
                    }
                });
            }

            let totalRequiredAllTeachers = 0;
            let totalAssignedAllTeachers = 0;
            let totalUnassignedAllTeachers = 0;

            const sortedTeachers = Object.values(teachers).sort((a, b) => a.teacherName.localeCompare(b.teacherName));
            sortedTeachers.forEach(teacher => {
                const totalRequiredHours = teacher.subjects.reduce((sum, s) => sum + s.hours, 0);
                const assignedHours = teacherAssignedCounts[teacher.teacher_id] || 0;
                const unassignedHours = totalRequiredHours - assignedHours;

                const row = teacherReportTableBody.insertRow();
                row.insertCell().textContent = teacher.teacher_id;
                row.insertCell().textContent = teacher.teacherName;
                row.insertCell().textContent = teacher.classInCharge;
                row.insertCell().textContent = `${assignedHours}/${totalRequiredHours}`; // New column
               // row.insertCell().textContent = assignedHours;
                row.insertCell().textContent = unassignedHours > 0 ? unassignedHours : 0;
                if (unassignedHours > 0) {
                    row.cells[4].classList.add('unassigned-subject'); // Updated index
                }

                totalRequiredAllTeachers += totalRequiredHours;
                totalAssignedAllTeachers += assignedHours;
                totalUnassignedAllTeachers += unassignedHours;
            });

            // Add summary row for teachers
            const teacherSummaryRow = teacherReportTableFoot.insertRow();
            teacherSummaryRow.insertCell().textContent = 'Total';
            teacherSummaryRow.insertCell().textContent = ''; // Empty for Teacher Name
            teacherSummaryRow.insertCell().textContent = totalRequiredAllTeachers;
            teacherSummaryRow.insertCell().textContent = totalAssignedAllTeachers;
            teacherSummaryRow.insertCell().textContent = totalUnassignedAllTeachers > 0 ? totalUnassignedAllTeachers : 0;


            // --- Class Report ---
            const classAssignedSubjects = {}; // { className: { subject: assignedHours } }
            const classTotalRequiredSubjects = {}; // { className: { subject: totalRequiredHours } }

            // Initialize total required subjects for each class
            requiredSlots.forEach(slot => {
                if (!classTotalRequiredSubjects[slot.class_name]) {
                    classTotalRequiredSubjects[slot.class_name] = {};
                }
                classTotalRequiredSubjects[slot.class_name][slot.subject] = 
                    (classTotalRequiredSubjects[slot.class_name][slot.subject] || 0) + 1;
            });

            // Count assigned subjects for each class
            for (const slotKey in currentTimetableData) {
                const assignments = currentTimetableData[slotKey];
                assignments.forEach(assignment => {
                    if (assignment) {
                        if (!classAssignedSubjects[assignment.class]) {
                            classAssignedSubjects[assignment.class] = {};
                        }
                        classAssignedSubjects[assignment.class][assignment.subject] = 
                            (classAssignedSubjects[assignment.class][assignment.subject] || 0) + 1;
                    }
                });
            }

            const allClassNames = Array.from(new Set(Object.keys(classTotalRequiredSubjects).concat(Object.keys(classAssignedSubjects)))).sort();

            let totalRequiredAllClasses = 0;
            let totalAssignedAllClasses = 0;
            let totalUnassignedAllClasses = 0;

            allClassNames.forEach(className => {
                const row = classReportTableBody.insertRow();
                row.insertCell().textContent = className;

                let totalAssignedPeriods = 0;
                let totalUnassignedPeriods = 0;
                let classRequiredPeriods = 0; // New variable for this class's total required periods
                const subjectsList = [];

                const subjectsForClass = classTotalRequiredSubjects[className] || {};
                for (const subjectName in subjectsForClass) {
                    const requiredHours = subjectsForClass[subjectName];
                    const assignedHours = (classAssignedSubjects[className] && classAssignedSubjects[className][subjectName]) || 0;
                    const unassigned = requiredHours - assignedHours;

                    classRequiredPeriods += requiredHours; // Accumulate for this class
                    totalAssignedPeriods += assignedHours;
                    totalUnassignedPeriods += unassigned;

                    if (unassigned > 0) {
                        subjectsList.push(`<span class="unassigned-subject">${subjectName} (Unassigned: ${unassigned}/${requiredHours})</span>`);
                    } else {
                        subjectsList.push(`${subjectName} (Assigned: ${assignedHours})`);
                    }
                }
                row.insertCell().textContent = classRequiredPeriods; // New column
                row.insertCell().textContent = totalAssignedPeriods;
                row.insertCell().textContent = totalUnassignedPeriods > 0 ? totalUnassignedPeriods : 0;
                if (totalUnassignedPeriods > 0) {
                    row.cells[3].classList.add('unassigned-subject'); // Updated index
                }
                row.insertCell().innerHTML = subjectsList.join('<br>');

                totalRequiredAllClasses += classRequiredPeriods;
                totalAssignedAllClasses += totalAssignedPeriods;
                totalUnassignedAllClasses += totalUnassignedPeriods;
            });

            // Add summary row for classes
            const classSummaryRow = classReportTableFoot.insertRow();
            classSummaryRow.insertCell().textContent = 'Total';
            classSummaryRow.insertCell().textContent = totalRequiredAllClasses;
            classSummaryRow.insertCell().textContent = totalAssignedAllClasses;
            classSummaryRow.insertCell().textContent = totalUnassignedAllClasses > 0 ? totalUnassignedAllClasses : 0;
            classSummaryRow.insertCell().textContent = ''; // Empty for Subjects column


        }

        fillEmptySlotsButton.addEventListener('click', () => {
            if (!areSlotsCreated) {
                showMessage('Please create slots and generate the timetable first.', 'error');
                return;
            }
            clearHighlights();
            cancelMovingSlot();
            fillEmptySlots();
        });


        // --- Event Listeners ---

        importButton.addEventListener('click', () => {
            headerModal.style.display = "block"; // Show the header structure modal
        });

        modalClose.onclick = function() {
            headerModal.style.display = "none";
        }

        window.onclick = function(event) {
            if (event.target == headerModal) {
                headerModal.style.display = "none";
            }
            // Hide custom context menu when clicking anywhere else
            if (!customContextMenu.classList.contains('hidden') && !customContextMenu.contains(event.target)) {
                customContextMenu.classList.add('hidden');
                contextMenuTargetCell = null;
            }
        }

        selectFileButton.addEventListener('click', () => {
            fileInput.click(); // Trigger file input click
            headerModal.style.display = "none"; // Hide modal after file selection
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                showMessage('No file selected.', 'error');
                return;
            }

            showLoading('Importing data...');
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = e.target.result;
                try {
                    const workbook = XLSX.read(data, { type: 'binary' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    // Use { header: 1 } to get an array of arrays (rows), and defval to handle empty cells
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                    processImportedData(jsonData);
                } catch (error) {
                    showMessage('Error processing file. Ensure it is a valid CSV/Excel format and not corrupted.', 'error');
                    console.error("File processing error:", error);
                } finally {
                    hideLoading();
                }
            };
            reader.onerror = () => {
                showMessage('Error reading file. Permission denied or file too large.', 'error');
                hideLoading();
            };

            // Determine how to read based on file extension
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file); // For CSV
            } else {
                reader.readAsBinaryString(file); // For XLSX
            }
        });

        createSlotsButton.addEventListener('click', () => {
            clearHighlights(); // Clear highlights when re-creating slots
            cancelMovingSlot(); // If a slot was being moved, cancel it
            if (originalDataRadio.checked) {
                if (!isDataImported) {
                    showMessage('Please import your data first using "Import CSV/Excel".', 'error');
                    return;
                }
                createSlots(importedTeachersRawData);
            } else { // Demo data selected
                generateDemoData();
            }
        });

        regenerateButton.addEventListener('click', () => {
            clearHighlights(); // Clear highlights before new generation
            cancelMovingSlot(); // If a slot was being moved, cancel it
            // Re-create slots based on the current data source (imported or demo)
            if (originalDataRadio.checked) {
                if (!isDataImported) {
                    showMessage('No imported data to regenerate from. Please import data or use demo data.', 'error');
                    return;
                }
                createSlots(importedTeachersRawData);
            } else {
                generateDemoData();
            }
            // generateTimetable(); // No need to call explicitly, createSlots now calls it
        });

        exportButton.addEventListener('click', () => {
            if (Object.keys(currentTimetableData).length === 0) {
                showMessage('No timetable to export. Please generate one first.', 'error');
                return;
            }

            const teachersToSave = {};
            for (const id in teachers) {
                teachersToSave[id] = {
                    ...teachers[id],
                    unavailable_slots: Array.from(teachers[id].unavailable_slots),
                };
            }

            if (Object.keys(teachersToSave).length === 0) {
                showMessage('No teacher data to export.', 'error');
                return;
            }

            // Step 1: Display timetable for export (ensure it's rendered in DOM)
            displayFullTimetable();

            // Step 2: Create a workbook and add timetable sheet
            const wb = XLSX.utils.book_new();
            const timetableSheet = XLSX.utils.table_to_sheet(timetableTable);
            XLSX.utils.book_append_sheet(wb, timetableSheet, 'Timetable');

            // Step 3: Prepare and add teacher data as second sheet
            const teacherDataArray = Object.keys(teachersToSave).map(id => {
                const teacher = teachersToSave[id];
                return {
                    'Teacher ID': id,
                    'Teacher Name': teacher.teacherName || '',
                    'Class In Charge': teacher.classInCharge || '',
                    'Subjects Taught': (teacher.subjects || []).map(s => `${s.class}-${s.name}-${s.hours}`).join(', '),
                    'Unavailable Periods': teacher.unavailable_slots.join(', ')
                };
            });

            const teacherSheet = XLSX.utils.json_to_sheet(teacherDataArray);
            XLSX.utils.book_append_sheet(wb, teacherSheet, 'Teachers');

            // Step 4: Export file
            XLSX.writeFile(wb, 'generated_timetable.xlsx');
            showMessage('Timetable and teacher data exported successfully!', 'success');

            // Step 5: Restore original view (if needed, though export doesn't change tab)
            const currentActiveTab = document.querySelector('.tab-button.active')?.dataset.tab;
            if (currentActiveTab === 'timetable-management-tab') {
                displayFullTimetable();
            }
        });


        // New: Export to Firestore button event listener
        exportToFirestoreButton.addEventListener('click', saveTimetableToFirestore);

        downloadTemplateButton.addEventListener('click', () => {
            const data = [ 
                ['Teacher ID', 'Teacher Name', 'Class In Charge', 'Subject1', 'Subject2', 'Unavailable Periods'],
                ['T001', 'Mr. Alex', '10A', '10A-Mathematics-5', '10B-Physics-3', 'Mo1, We3'],
                ['T002', 'Ms. Betty', '10B', '10B-English-4', '10C-History-2', ''],
                ['T003', 'C. Patel', '9A', '9A-Science-5', '10A-Chemistry-3', 'Sa1, Sa2']
            ];

            const workbook = XLSX.utils.book_new();
            const worksheet = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Timetable_Template');
            XLSX.writeFile(workbook, 'timetable_template.xlsx');
            showMessage('Template downloaded successfully!', 'success');
        });

        clearSavedDataButton.addEventListener('click', () => {
            showCustomConfirmation(
                'Are you sure you want to clear ALL saved data (local and cloud)? This cannot be undone.',
                async () => { // On Confirm
                    showLoading('Clearing all data...');
                    try {
                        // Clear local storage
                        localStorage.removeItem(LOCAL_STORAGE_KEY_TIMETABLE);
                        localStorage.removeItem(LOCAL_STORAGE_KEY_UNASSIGNED);
                        localStorage.removeItem(LOCAL_STORAGE_KEY_TEACHERS);
                        localStorage.removeItem(LOCAL_STORAGE_KEY_SLOTS);

                        // Clear global state variables
                        currentTimetableData = {};
                        currentUnassignedSlots = [];
                        teachers = {};
                        requiredSlots = [];
                        isDataImported = false;
                        areSlotsCreated = false;
                        cancelMovingSlot(); // Ensure moving slot state is cleared
                        undoStack = []; // Clear undo stack
                        redoStack = []; // Clear redo stack

                        // Clear UI elements
                        timetableTable.querySelector('thead').innerHTML = '';
                        timetableTable.querySelector('tbody').innerHTML = '';
                        timetableContainer.classList.add('hidden');
                        
                        individualTimetableTable.querySelector('thead').innerHTML = '';
                        individualTimetableTable.querySelector('tbody').innerHTML = '';
                        individualTimetableDisplay.classList.add('hidden');
                        
                        displayUnassignedSlots([]); // Clear unassigned slots section (will also hide if on management tab)
                        clearHighlights(); // Clear any highlights
                        populateDropdowns(); // Clear dropdowns
                        populateUnassignedFilterDropdowns(); // Clear unassigned filter dropdowns
                        generateReports(); // Clear reports

                        // --- Firebase Clearing ---
                        await firebaseReadyPromise; // Ensure Firebase is ready
                        if (db && userId) {
                            const basePath = getFirestoreBasePath();
                            const collectionsToClear = [
                                FIRESTORE_COLLECTION_TEACHERS_DATA,
                                FIRESTORE_COLLECTION_CLASS_DATA,
                                FIRESTORE_COLLECTION_TIMETABLES,
                                FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE,
                            ];

                            for (const collectionName of collectionsToClear) {
                                try {
                                    const collectionRef = collection(db, `${basePath}/${collectionName}`);
                                    const querySnapshot = await getDocs(collectionRef);
                                    const batch = writeBatch(db);
                                    querySnapshot.forEach(docSnap => {
                                        batch.delete(docSnap.ref);
                                    });
                                    await batch.commit();
                                    console.log(`Collection '${collectionName}' cleared in Firestore.`);
                                } catch (e) {
                                    console.warn(`Error clearing collection '${collectionName}':`, e);
                                    // Specific handling for 'mainTimetable' doc if it's not a subcollection
                                    if (collectionName === FIRESTORE_COLLECTION_TIMETABLES) {
                                        const mainTimetableDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_TIMETABLES}`, 'mainTimetable');
                                        await deleteDoc(mainTimetableDocRef).catch(err => console.warn("Error deleting mainTimetable doc:", err));
                                    }
                                    // Specific handling for 'allClasses' doc if it's not a subcollection
                                    if (collectionName === FIRESTORE_COLLECTION_CLASS_DATA) {
                                        const allClassesDocRef = doc(db, `${basePath}/${FIRESTORE_COLLECTION_CLASS_DATA}`, 'allClasses');
                                        await deleteDoc(allClassesDocRef).catch(err => console.warn("Error deleting allClasses doc:", err));
                                    }
                                }
                            }
                            showMessage('All saved data (local & cloud) cleared!', 'success');
                            console.log('All saved data (local & cloud) cleared.');
                        } else {
                            showMessage('Local data cleared. Cloud data not cleared (Firebase not ready).', 'info');
                        }
                    } catch (error) {
                        showMessage('Error clearing some data.', 'error');
                        console.error('Error during clearing data:', error);
                    } finally {
                        hideLoading();
                        updateButtonStates();
                    }
                },
                () => { // On Cancel
                    showMessage('Clearing data cancelled.', 'info');
                }
            );
        });
        printTeacherReportButton.addEventListener('click',()=>{
            printTeacherReport();
        });
        printClassReportButton.addEventListener('click',()=>{
            printClassReport();
        });
        // New: Clear All Assignments button event listener
        clearAllAssignmentsButton.addEventListener('click', () => {
            showCustomConfirmation(
                'Are you sure you want to clear ALL assignments from the timetable? They will be moved back to unassigned slots.',
                () => { // On Confirm
                    // Save state before clearing all assignments
                    saveStateForUndo();

                    showLoading('Clearing all assignments...');
                    // Move all assigned slots back to currentUnassignedSlots
                    for (const slotKey in currentTimetableData) {
                        currentTimetableData[slotKey].forEach(assignment => {
                            addUniqueUnassignedSlot({ // Use addUniqueUnassignedSlot
                                class_name: assignment.class,
                                subject: assignment.subject,
                                teacher_id: assignment.teacher_id,
                                isClassCharge: teachers[assignment.teacher_id]?.classInCharge === assignment.class,
                                isLocked: false, // Unlocked when unassigned
                                slotNumber: assignment.slotNumber // Ensure slotNumber is carried over
                            });
                        });
                    }
                    currentTimetableData = {}; // Clear the assigned timetable
                    cancelMovingSlot(); // Clear any active moving slot
                    refreshCurrentTimetableDisplay(); // Re-render to show empty timetable and updated unassigned list
                    showMessage('All assignments cleared and moved to unassigned slots.', 'success');
                    hideLoading();
                },
                () => { // On Cancel
                    showMessage('Clearing assignments cancelled.', 'info');
                }
            );
        });


        // Event listeners for the "View/Edit" buttons in "Timetable Management"
        viewTeacherTimetableEditableButton.addEventListener('click', () => {
            const teacherId = teacherDropdownEditable.value;
            if (teacherId) {
                displayTeacherTimetableEditable(teacherId);
            } else {
                showMessage('Please select a teacher from the dropdown.', 'error');
            }
        });

        viewClassTimetableEditableButton.addEventListener('click', () => {
            const className = classDropdownEditable.value;
            if (className) {
                displayClassTimetableEditable(className);
            } else {
                showMessage('Please select a class from the dropdown.', 'error');
            }
        });

        // Event listener for the "View/Edit Full Timetable" button in "Timetable Management"
        viewAllTimetableButton.addEventListener('click', () => {
            displayFullTimetable();
        });

        // Event listeners for print buttons in "Reports" tab
        printAllTeacherTimetablesButton.addEventListener('click', () => {
            if (Object.keys(currentTimetableData).length === 0) {
                showMessage('No timetable generated to print.', 'error');
                return;
            }

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
    <html>
    <head>
        <title>All Teacher Timetables</title>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
            body { font-family: 'Inter', sans-serif; margin: 20px; }
            h1 { text-align: center; margin-bottom: 30px; font-size: 1.8rem; }
            h2 { text-align: center; margin-top: 30px; margin-bottom: 15px; font-size: 1.2rem; }

            .page-block {
                page-break-after: always;
                display: flex;
                flex-direction: column;
                gap: 30px;
            }

            .teacher-container {
                page-break-inside: avoid;
            }

            .timetable-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 10px;
            }
            .timetable-table th, .timetable-table td {
                border: 1px solid #000;
                padding: 8px;
                text-align: center;
                font-size: 0.75rem;
            }
            .timetable-table th {
                background-color: #f0f0f0;
            }
            .teacher-print-summary {
                margin-bottom: 10px;
                font-size: 0.85rem;
                text-align: left;
                border: 1px solid #ddd;
                padding: 10px;
                border-radius: 5px;
                background-color: #f9f9f9;
            }
            .teacher-print-summary h3 {
                font-size: 1rem;
                margin: 0 0 5px 0;
            }
            .teacher-print-summary p {
                margin: 0;
                line-height: 1.4;
            }

            @media print {
                .page-block { page-break-after: always; }
                h1 { font-size: 14pt; }
                h2 { font-size: 12pt; }
                .timetable-table th, .timetable-table td { font-size: 8pt; }
            }
        </style>
    </head>
    <body>
        <h1>All Teacher Timetables</h1>
`);

const sortedTeachers = Object.values(teachers).sort((a, b) =>
    a.teacherName.localeCompare(b.teacherName)
);

// Write 2 timetables per block
for (let i = 0; i < sortedTeachers.length; i += 3) {
    printWindow.document.write(`<div class="page-block">`);

    for (let j = i; j < i + 3 && j < sortedTeachers.length; j++) {
        const teacher = sortedTeachers[j];
        printWindow.document.write(`<div class="teacher-container">`);
        printWindow.document.write(getTeacherTimetableHtml(teacher.teacher_id, currentTimetableData));
        printWindow.document.write(`</div>`);
    }

    printWindow.document.write(`</div>`);
}

printWindow.document.write(`</body></html>`);

           
            printWindow.document.close();
            printWindow.focus();
            printWindow.print();
        });

        printAllClassTimetablesButton.addEventListener('click', () => {
            if (Object.keys(currentTimetableData).length === 0) {
                showMessage('No timetable generated to print.', 'error');
                return;
            }

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                <head>
                    <title>All Class Timetables</title>
                    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
                    <style>
                        body { font-family: 'Inter', sans-serif; margin: 20px; }
                        h1 { text-align: center; margin-bottom: 30px; font-size: 1.8rem; }
                        h2 { text-align: center; margin-top: 30px; margin-bottom: 15px; font-size: 1.2rem; }
                        .timetable-table {
                            width: 100%;
                            border-collapse: collapse;
                            margin-bottom: 20px;
                            page-break-inside: auto; /* Allow table to break across pages */
                        }
                        .timetable-table th, .timetable-table td {
                            border: 1px solid #000;
                            padding: 8px;
                            text-align: center;
                            font-size: 0.75rem; /* Smaller font for more content per page */
                        }
                        .timetable-table th {
                            background-color: #f0f0f0;
                        }
                        @media print {
                           .page-block { page-break-after: always; }
                h1 { font-size: 14pt; }
                h2 { font-size: 12pt; }
                .timetable-table th, .timetable-table td { font-size: 8pt; }
                        }
                    </style>
                </head>
                <body>
                    <h1>All Class Timetables</h1>
            `);

            // Add all class timetables
            const uniqueClasses = Array.from(new Set(requiredSlots.map(s => s.class_name))).sort();
            
            // Write 2 timetables per block
for (let i = 0; i < uniqueClasses.length; i += 2) {
    printWindow.document.write(`<div class="page-block">`);

    for (let j = i; j < i + 2 && j < uniqueClasses.length; j++) {
        const className = uniqueClasses[j];
        printWindow.document.write(`<div class="teacher-container">`);
        printWindow.document.write(getClassTimetableHtml(className, currentTimetableData));
        printWindow.document.write(`</div>`);
    }

    printWindow.document.write(`</div>`);
}


            printWindow.document.write(`</body></html>`);
            printWindow.document.close();
            printWindow.focus();
            printWindow.print();
        });


        // Event listeners for dropdown changes to enable/disable view buttons
        teacherDropdownEditable.addEventListener('change', updateButtonStates);
        classDropdownEditable.addEventListener('change', updateButtonStates);

        // Tab switching logic
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTabId = button.dataset.tab;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                document.getElementById(targetTabId).classList.add('active');

                // Hide all timetable displays by default on tab change
                timetableContainer.classList.add('hidden');
                individualTimetableDisplay.classList.add('hidden');
                availableSlotsContainer.classList.add('hidden'); // Hide unassigned slots by default

                clearHighlights(); // Clear highlights when switching tabs
                cancelMovingSlot(); // Clear any active moving slot

                if (targetTabId === 'reports-tab') {
                    generateReports(); // Generate reports when the tab is opened
                } else if (targetTabId === 'timetable-management-tab') {
                    // When "Timetable Management" tab is active, display the full timetable (editable).
                    displayFullTimetable();
                }
                updateButtonStates(); // Update button states after tab switch
            });
        });

        // --- Custom Context Menu Logic ---
        function handleContextMenu(event) {
            const targetCell = event.target.closest('td[data-slot-key]');
            if (targetCell) {
                event.preventDefault(); // Prevent default browser context menu
                contextMenuTargetCell = targetCell; // Store the clicked cell

                const slotKey = targetCell.dataset.slotKey;
                const cellTeacherId = targetCell.dataset.teacherId;
                const cellClassName = targetCell.dataset.className;

                let assignmentToConsider = null;
                const assignmentsInThisPeriod = currentTimetableData[slotKey] || [];

                if (currentMainTimetableDisplay.type === 'full') {
                    assignmentToConsider = assignmentsInThisPeriod.find(a => a && a.teacher_id === cellTeacherId);
                } else if (currentMainTimetableDisplay.type === 'teacher') {
                    assignmentToConsider = assignmentsInThisPeriod.find(a => a && a.teacher_id === currentMainTimetableDisplay.id);
                } else if (currentMainTimetableDisplay.type === 'class') {
                    assignmentToConsider = assignmentsInThisPeriod.find(a => a && a.class === currentMainTimetableDisplay.id);
                }

                // Only show context menu if there's an assignment in the cell relevant to the current view
                if (assignmentToConsider) {
                    // Set Lock/Unlock option text
                    lockUnlockOption.textContent = assignmentToConsider.isLocked ? 'Unlock Slot' : 'Lock Slot';
                    // Enable/disable Unassign based on lock status
                    unassignSlotOption.disabled = assignmentToConsider.isLocked;

                    // Position the custom context menu
                    customContextMenu.style.left = `${event.clientX}px`;
                    customContextMenu.style.top = `${event.clientY}px`;
                    customContextMenu.classList.remove('hidden');
                } else {
                    // If no assignment, hide the context menu and disable all options
                    customContextMenu.classList.add('hidden');
                    contextMenuTargetCell = null;
                    lockUnlockOption.disabled = true;
                    unassignSlotOption.disabled = true;
                }
            }
        }

        // Attach context menu listener to both timetable tables
        timetableTable.addEventListener('contextmenu', handleContextMenu);
        individualTimetableTable.addEventListener('contextmenu', handleContextMenu);


        lockUnlockOption.addEventListener('click', () => {
            if (contextMenuTargetCell) {
                const slotKey = contextMenuTargetCell.dataset.slotKey;
                const cellTeacherId = contextMenuTargetCell.dataset.teacherId;
                const cellClassName = contextMenuTargetCell.dataset.className;
                
                let assignmentsInThisPeriod = currentTimetableData[slotKey] || [];
                let assignmentToModify = null;

                // Find the specific assignment to modify based on the current view context
                if (currentMainTimetableDisplay.type === 'full') {
                    assignmentToModify = assignmentsInThisPeriod.find(a => a && a.teacher_id === cellTeacherId);
                } else if (currentMainTimetableDisplay.type === 'teacher') {
                    assignmentToModify = assignmentsInThisPeriod.find(a => a && a.teacher_id === currentMainTimetableDisplay.id);
                } else if (currentMainTimetableDisplay.type === 'class') {
                    assignmentToModify = assignmentsInThisPeriod.find(a => a && a.class === currentMainTimetableDisplay.id);
                }

                if (assignmentToModify) {
                    // Save state before modifying
                    saveStateForUndo();
                    assignmentToModify.isLocked = !assignmentToModify.isLocked; // Toggle lock state
                    showMessage(`Slot ${assignmentToModify.subject}${assignmentToModify.slotNumber ? '-' + assignmentToModify.slotNumber : ''} for ${assignmentToModify.teacherName} (${assignmentToModify.class}) is now ${assignmentToModify.isLocked ? 'LOCKED' : 'UNLOCKED'}.`, 'info');
                    refreshCurrentTimetableDisplay(); // Re-render to show lock icon/style
                } else {
                    showMessage('No assignment found in this cell to lock/unlock.', 'error');
                }
                customContextMenu.classList.add('hidden');
                contextMenuTargetCell = null;
            }
        });

        unassignSlotOption.addEventListener('click', () => {
            if (contextMenuTargetCell) {
                const slotKey = contextMenuTargetCell.dataset.slotKey;
                const cellTeacherId = contextMenuTargetCell.dataset.teacherId;
                const cellClassName = contextMenuTargetCell.dataset.className;

                let assignmentsInThisPeriod = currentTimetableData[slotKey] || [];
                let assignmentToUnassign = null;

                if (currentMainTimetableDisplay.type === 'full') {
                    assignmentToUnassign = assignmentsInThisPeriod.find(a => a && a.teacher_id === cellTeacherId);
                } else if (currentMainTimetableDisplay.type === 'teacher') {
                    assignmentToUnassign = assignmentsInThisPeriod.find(a => a && a.teacher_id === currentMainTimetableDisplay.id);
                } else if (currentMainTimetableDisplay.type === 'class') {
                    assignmentToUnassign = assignmentsInThisPeriod.find(a => a && a.class === currentMainTimetableDisplay.id);
                }

                if (assignmentToUnassign) {
                    if (assignmentToUnassign.isLocked) {
                        showMessage('This slot is locked and cannot be unassigned. Please unlock it first.', 'error');
                        customContextMenu.classList.add('hidden');
                        contextMenuTargetCell = null;
                        return;
                    }

                    showCustomConfirmation(
                        `Do you want to unassign "${assignmentToUnassign.subject}${assignmentToUnassign.slotNumber ? '-' + assignmentToUnassign.slotNumber : ''}" for "${assignmentToUnassign.class}" from "${assignmentToUnassign.teacherName}" at ${slotKey}?`,
                        () => { // On Confirm
                            // Save state before unassigning
                            saveStateForUndo();

                            addUniqueUnassignedSlot({ // Use addUniqueUnassignedSlot
                                class_name: assignmentToUnassign.class,
                                subject: assignmentToUnassign.subject,
                                teacher_id: assignmentToUnassign.teacher_id,
                                isClassCharge: teachers[assignmentToUnassign.teacher_id]?.classInCharge === assignmentToUnassign.class,
                                isLocked: false, // Unlocked when unassigned
                                slotNumber: assignmentToUnassign.slotNumber
                            });
                            
                            currentTimetableData[slotKey] = assignmentsInThisPeriod.filter(
                                (assignment) => assignment && !(
                                    assignment.teacher_id === assignmentToUnassign.teacher_id &&
                                    assignment.class === assignmentToUnassign.class &&
                                    assignment.subject === assignmentToUnassign.subject &&
                                    assignment.slotNumber === assignmentToUnassign.slotNumber
                                )
                            );

                            if (currentTimetableData[slotKey].length === 0) {
                                delete currentTimetableData[slotKey];
                            }

                            showMessage('Slot unassigned and moved to unassigned list.', 'success');
                            refreshCurrentTimetableDisplay();
                        },
                        () => { // On Cancel
                            showMessage('Unassignment cancelled.', 'info');
                        }
                    );
                } else {
                    showMessage('No assignment found in this cell to unassign.', 'error');
                }
                customContextMenu.classList.add('hidden');
                contextMenuTargetCell = null;
            }
        });


        // --- Unassigned Slot Filtering ---
        filterUnassignedClassDropdown.addEventListener('change', () => {
            cancelMovingSlot(); // If a slot was being moved, cancel it before filtering
            displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value);
            updateButtonStates();
        });

        filterUnassignedTeacherDropdown.addEventListener('change', () => {
            cancelMovingSlot(); // If a slot was being moved, cancel it before filtering
            displayUnassignedSlots(currentUnassignedSlots, filterUnassignedClassDropdown.value, filterUnassignedTeacherDropdown.value);
            updateButtonStates();
        });

        clearUnassignedFiltersButton.addEventListener('click', () => {
            cancelMovingSlot(); // If a slot was being moved, cancel it before clearing filters
            filterUnassignedClassDropdown.value = '';
            filterUnassignedTeacherDropdown.value = '';
            displayUnassignedSlots(currentUnassignedSlots, null, null); // Display all unassigned slots
            updateButtonStates();
        });

        // --- Undo/Redo Functions ---

        /**
         * Saves the current state of timetable data and unassigned slots to the undo stack.
         * Clears the redo stack when a new state is saved.
         */
        function saveStateForUndo() {
            // Deep copy current states to avoid reference issues
            const state = {
                timetable: JSON.parse(JSON.stringify(currentTimetableData)),
                unassigned: JSON.parse(JSON.stringify(currentUnassignedSlots))
            };
            undoStack.push(state);

            // Limit undo stack size
            if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                undoStack.shift(); // Remove the oldest state
            }
            redoStack = []; // Clear redo stack on new action
            updateButtonStates();
            console.log('State saved for undo. Undo stack size:', undoStack.length);
        }

        /**
         * Undoes the last action by restoring the previous state from the undo stack.
         */
        function undoLastAction() {
            if (undoStack.length > 0) {
                // Save current state to redo stack before undoing
                const currentState = {
                    timetable: JSON.parse(JSON.stringify(currentTimetableData)),
                    unassigned: JSON.parse(JSON.stringify(currentUnassignedSlots))
                };
                redoStack.push(currentState);

                const prevState = undoStack.pop();
                currentTimetableData = prevState.timetable;
                currentUnassignedSlots = prevState.unassigned;

                showMessage('Last action undone.', 'info');
                refreshCurrentTimetableDisplay(); // Re-render UI
                updateButtonStates();
                console.log('Undo performed. Undo stack size:', undoStack.length, 'Redo stack size:', redoStack.length);
            } else {
                showMessage('Nothing to undo.', 'info');
            }
        }

        /**
         * Redoes the last undone action by restoring the state from the redo stack.
         */
        function redoLastAction() {
            if (redoStack.length > 0) {
                // Save current state to undo stack before redoing
                const currentState = {
                    timetable: JSON.parse(JSON.stringify(currentTimetableData)),
                    unassigned: JSON.parse(JSON.stringify(currentUnassignedSlots))
                };
                undoStack.push(currentState);

                // Limit undo stack size (important if redoing multiple times)
                if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                    undoStack.shift();
                }

                const nextState = redoStack.pop();
                currentTimetableData = nextState.timetable;
                currentUnassignedSlots = nextState.unassigned;

                showMessage('Last action redone.', 'info');
                refreshCurrentTimetableDisplay(); // Re-render UI
                updateButtonStates();
                console.log('Redo performed. Undo stack size:', undoStack.length, 'Redo stack size:', redoStack.length);
            } else {
                showMessage('Nothing to redo.', 'info');
            }
        }

        // Attach event listeners for Undo/Redo buttons
        undoButton.addEventListener('click', undoLastAction);
        redoButton.addEventListener('click', redoLastAction);

        // Keyboard shortcuts for Undo/Redo
        document.addEventListener('keydown', (event) => {
            // Check for Ctrl+Z (or Cmd+Z on Mac)
            if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
                event.preventDefault(); // Prevent browser's default undo
                undoLastAction();
            }
            // Check for Ctrl+Y (or Cmd+Y on Mac)
            if ((event.ctrlKey || event.metaKey) && event.key === 'y') {
                event.preventDefault(); // Prevent browser's default redo
                redoLastAction();
            }
        });


        function printTeacherReport() {
    const table = document.getElementById('teacher-report-table');
    printTable(table, 'Teacher Timetable Summary Report',"");
}

function printClassReport() {
    const table = document.getElementById('class-report-table');
    printTable(table, 'Class Timetable Summary Report','');
}

        /**
         * Loads saved data from Local Storage or Firebase on page load.
         */
        async function loadDataFromFirebaseIfNewer(localTime) {
    let cloudTime;
    let loaded = false;

    try {
        const timetableTimeDocRef = doc( db,`${basePath}/${FIRESTORE_COLLECTION_UNASSIGNED_SLOTS_FIREBASE}`,'updatedtime');
                //const querySnapshot = await getDoc(timetableTimeDocRef);
                const timetabletimeDocSnap = await getDoc(timetableTimeDocRef);
                var fireBaseTime = timetabletimeDocSnap.data();
                var localTime = localStorage.getItem("timetableupdated");
                cloudTime=fireBaseTime.timestamp;

        
        if (!cloudTime || !localTime || new Date(cloudTime) > new Date(localTime)) {
            const teachersLoaded = await loadTeachersDataFromFirestore();
            const classesLoaded = await loadClassDataFromFirestore();
            const timetableLoaded = await loadTimetableFromFirestore();

            if (teachersLoaded && classesLoaded && timetableLoaded) {
                isDataImported = true;
                areSlotsCreated = true;
                showMessage('Timetable and data loaded from cloud!', 'success');
                console.log('Loaded from Firebase');
                loaded = true;
            }
        }
    } catch (e) {
        console.error('Error checking Firebase timestamp or loading data:', e);
    }

    return loaded;
}

function loadDataFromLocalStorage() {
    const savedTimetable = localStorage.getItem(LOCAL_STORAGE_KEY_TIMETABLE);
    const savedUnassigned = localStorage.getItem(LOCAL_STORAGE_KEY_UNASSIGNED);
    const savedSlots = localStorage.getItem(LOCAL_STORAGE_KEY_SLOTS);
    const savedTeachers = localStorage.getItem(LOCAL_STORAGE_KEY_TEACHERS);

    if (savedTimetable && savedUnassigned && savedTeachers && savedSlots) {
        currentTimetableData = JSON.parse(savedTimetable);
        currentUnassignedSlots = [];
        JSON.parse(savedUnassigned).forEach(slot => addUniqueUnassignedSlot(slot));

        requiredSlots = JSON.parse(savedSlots);

        const loadedTeachers = JSON.parse(savedTeachers);
        teachers = {};
        for (const id in loadedTeachers) {
            teachers[id] = {
                ...loadedTeachers[id],
                unavailable_slots: new Set(loadedTeachers[id].unavailable_slots),
            };
        }

        isDataImported = true;
        areSlotsCreated = true;
        showMessage('Timetable and data loaded from local storage.', 'success');
        console.log('Loaded from Local Storage');
        return true;
    }
    return false;
}

async function loadSavedData() {
    showLoading('Loading saved data...');
    const localTime = localStorage.getItem("timetableupdated");
    let loadedSuccessfully = false;

    try {
        if (db && userId) {
            loadedSuccessfully = await loadDataFromFirebaseIfNewer(localTime);
        }

        if (!loadedSuccessfully) {
            loadedSuccessfully = loadDataFromLocalStorage();
        }

        if (!loadedSuccessfully) {
            isDataImported = false;
            areSlotsCreated = false;
            showMessage('No saved timetable found in cloud or local.', 'info');
        }
    } catch (e) {
        console.error('Error during loadSavedData():', e);
        showMessage('Failed to load timetable. Data might be corrupted or inaccessible.', 'error');
        localStorage.removeItem(LOCAL_STORAGE_KEY_TIMETABLE);
        localStorage.removeItem(LOCAL_STORAGE_KEY_UNASSIGNED);
        localStorage.removeItem(LOCAL_STORAGE_KEY_TEACHERS);
        localStorage.removeItem(LOCAL_STORAGE_KEY_SLOTS);
        isDataImported = false;
        areSlotsCreated = false;
    } finally {
        if (loadedSuccessfully) {
            populateDropdowns();
            populateUnassignedFilterDropdowns();
            if (Object.keys(currentTimetableData).length > 0) {
                document.querySelector('.tab-button[data-tab="timetable-management-tab"]').click();
                displayFullTimetable();
            }
            saveStateForUndo();
        } else {
            timetableContainer.classList.add('hidden');
            individualTimetableDisplay.classList.add('hidden');
            availableSlotsContainer.classList.add('hidden');
            populateUnassignedFilterDropdowns();
        }

        hideLoading();
        updateButtonStates();
    }
}



        // --- Demo Data ---
        function generateDemoData() {
            const demoData = [
                {
                    teacherId: 'T001',
                    teacherName: 'A. Sharma',
                    classInCharge: '10A',
                    subjects: [
                        { name: 'Mathematics', hours: 5, class: '10A' },
                        { name: 'Physics', hours: 3, class: '10A' },
                        { name: 'Mathematics', hours: 2, class: '9B' },
                    ],
                    unavailableSlots: ['Mo1', 'Tu5', 'Fr7'],
                },
                {
                    teacherId: 'T002',
                    teacherName: 'B. Singh',
                    classInCharge: '10B',
                    subjects: [
                        { name: 'English', hours: 5, class: '10B' },
                        { name: 'History', hours: 3, class: '10B' },
                        { name: 'English', hours: 2, class: '9A' },
                    ],
                    unavailableSlots: ['We3', 'Th2'],
                },
                {
                    teacherId: 'T003',
                    teacherName: 'C. Patel',
                    classInCharge: '9A',
                    subjects: [
                        { name: 'Science', hours: 5, class: '9A' },
                        { name: 'Chemistry', hours: 3, class: '10A' },
                        { name: 'Science', hours: 2, class: '8C' },
                    ],
                    unavailableSlots: ['Sa1', 'Sa2'],
                },
                {
                    teacherId: 'T004',
                    teacherName: 'D. Kumar',
                    classInCharge: '8A',
                    subjects: [
                        { name: 'Social Studies', hours: 4, class: '8A' },
                        { name: 'Geography', hours: 3, class: '8A' },
                        { name: 'Art', hours: 2, class: '7B' },
                    ],
                    unavailableSlots: ['Mo7'],
                },
                {
                    teacherId: 'T005',
                    teacherName: 'E. Devi',
                    classInCharge: '7A',
                    subjects: [
                        { name: 'Physical Education', hours: 3, class: '7A' },
                        { name: 'Music', hours: 2, class: '8A' },
                        { name: 'Physical Education', hours: 2, class: '10A' },
                    ],
                    unavailableSlots: ['Tu1'],
                },
            ];
            createSlots(demoData);
        }

        // --- Initial setup ---
        // Ensure Firebase is ready before attempting to load data
        firebaseReadyPromise.then(() => {
            loadSavedData(); // Attempt to load saved data on page load
        });
        
        updateButtonStates(); // Set initial button states on page load

        // Enable/Disable create slots button based on radio selection
        demoDataRadio.addEventListener('change', updateButtonStates);
        originalDataRadio.addEventListener('change', updateButtonStates);

        // Set initial active tab to 'timetable-management-tab'
        document.addEventListener('DOMContentLoaded', () => {
            // This click will be handled by loadSavedData if data is loaded, otherwise it will just activate the tab.
            // Removed the direct click here as loadSavedData now handles it for loaded states.
            // If no data is loaded, the tab will default to 'timetable-management-tab' due to initial HTML class.
        });

        document.getElementById("loadFromFirebaseBtn").addEventListener("click", async () => {
    showLoading("Loading data from Firebase...");

    try {
        const teachersLoaded = await loadTeachersDataFromFirestore();
        const classesLoaded = await loadClassDataFromFirestore();
        const timetableLoaded = await loadTimetableFromFirestore();

        if (teachersLoaded && classesLoaded && timetableLoaded) {
            showMessage("Timetable loaded successfully from Firebase!", "success");
            displayFullTimetable();
            populateDropdowns();
            populateUnassignedFilterDropdowns();
            saveStateForUndo();
        } else {
            showMessage("Some data failed to load from Firebase.", "warning");
        }
    } catch (err) {
        console.error("Error loading from Firebase:", err);
        showMessage("Failed to load from Firebase.", "error");
    } finally {
        hideLoading();
        updateButtonStates();
    }
});


    </script>
</body>
</html>
